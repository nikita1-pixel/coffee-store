{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/app-router-headers.ts"],"sourcesContent":["export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n"],"names":["RSC_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_URL","RSC_CONTENT_TYPE_HEADER","FLIGHT_HEADERS","NEXT_RSC_UNION_QUERY","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_HTML_REQUEST_ID_HEADER"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAMA,aAAa,MAAc;AACjC,MAAMC,gBAAgB,cAAsB;AAI5C,MAAMC,gCAAgC,yBAAiC;AACvE,MAAMC,8BAA8B,uBAA+B;AAKnE,MAAMC,sCACX,+BAAuC;AAClC,MAAMC,0BAA0B,mBAA2B;AAC3D,MAAMC,+BAA+B,4BAAoC;AACzE,MAAMC,WAAW,WAAmB;AACpC,MAAMC,0BAA0B,mBAA2B;AAE3D,MAAMC,iBAAiB;IAC5BT;IACAE;IACAC;IACAE;IACAD;CACD,CAAS;AAEH,MAAMM,uBAAuB,OAAe;AAE5C,MAAMC,gCAAgC,sBAA8B;AACpE,MAAMC,2BAA2B,qBAA6B;AAC9D,MAAMC,6BAA6B,0BAAkC;AACrE,MAAMC,8BAA8B,2BAAmC;AACvE,MAAMC,2BAA2B,qBAA6B;AAC9D,MAAMC,+BAA+B,4BAAoC;AACzE,MAAMC,yBAAyB,sBAA8B;AAC7D,MAAMC,8BAA8B,2BAAmC","ignoreList":[0]}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/app-router-headers.ts"],"sourcesContent":["export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n"],"names":["RSC_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_URL","RSC_CONTENT_TYPE_HEADER","FLIGHT_HEADERS","NEXT_RSC_UNION_QUERY","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_HTML_REQUEST_ID_HEADER"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAMA,aAAa,MAAc;AACjC,MAAMC,gBAAgB,cAAsB;AAI5C,MAAMC,gCAAgC,yBAAiC;AACvE,MAAMC,8BAA8B,uBAA+B;AAKnE,MAAMC,sCACX,+BAAuC;AAClC,MAAMC,0BAA0B,mBAA2B;AAC3D,MAAMC,+BAA+B,4BAAoC;AACzE,MAAMC,WAAW,WAAmB;AACpC,MAAMC,0BAA0B,mBAA2B;AAE3D,MAAMC,iBAAiB;IAC5BT;IACAE;IACAC;IACAE;IACAD;CACD,CAAS;AAEH,MAAMM,uBAAuB,OAAe;AAE5C,MAAMC,gCAAgC,sBAA8B;AACpE,MAAMC,2BAA2B,qBAA6B;AAC9D,MAAMC,6BAA6B,0BAAkC;AACrE,MAAMC,8BAA8B,2BAAmC;AACvE,MAAMC,2BAA2B,qBAA6B;AAC9D,MAAMC,+BAA+B,4BAAoC;AACzE,MAAMC,yBAAyB,sBAA8B;AAC7D,MAAMC,8BAA8B,2BAAmC","ignoreList":[0]}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","HTTP_ERROR_FALLBACK_ERROR_CODE","isHTTPAccessFallbackError","error","digest","prefix","httpStatus","split","has","Number","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","status"],"mappings":";;;;;;;;;;;;AAAO,MAAMA,wBAAwB;IACnCC,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB,EAAC;AAED,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACP;AAErC,MAAMQ,iCAAiC,2BAA0B;AAajE,SAASC,0BACdC,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWJ,kCACXJ,cAAcW,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASI,4BACdP,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASK,mCACdC,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;;AAAO,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA;MAIX","ignoreList":[0]}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN"],"mappings":";;;;;;;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;;AAEpD,MAAMC,sBAAsB,gBAAe;AAE3C,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;MAGX;AAaM,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcd,6QAAAA;AAElB","ignoreList":[0]}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["RedirectStatusCode","RedirectType","isRedirectError","REDIRECT_ERROR_CODE","actionAsyncStorage","window","require","undefined","getRedirectError","url","type","statusCode","TemporaryRedirect","error","Error","digest","redirect","getStore","isAction","push","replace","permanentRedirect","PermanentRedirect","getURLFromRedirectError","split","slice","join","getRedirectTypeFromError","getRedirectStatusCodeFromError","Number","at"],"mappings":";;;;;;;;;;;;;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;AAC3D,SACEC,YAAY,EAEZC,eAAe,EACfC,mBAAmB,QACd,mBAAkB;;;AAEzB,MAAMC,qBACJ,OAAOC,WAAW,qBAEZC,QAAQ,8KACRF,kBAAkB,GACpBG;AAEC,SAASC,iBACdC,GAAW,EACXC,IAAkB,EAClBC,aAAiCX,6QAAAA,CAAmBY,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMX,qQAAAA,GAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CU,MAAME,MAAM,GAAG,GAAGZ,qQAAAA,CAAoB,CAAC,EAAEO,KAAK,CAAC,EAAED,IAAI,CAAC,EAAEE,WAAW,CAAC,CAAC;IACrE,OAAOE;AACT;AAcO,SAASG,SACd,2BAA2B,GAC3BP,GAAW,EACXC,IAAmB;IAEnBA,SAASN,oBAAoBa,YAAYC,WACrCjB,8PAAAA,CAAakB,IAAI,GACjBlB,8PAAAA,CAAamB,OAAO;IAExB,MAAMZ,iBAAiBC,KAAKC,MAAMV,6QAAAA,CAAmBY,iBAAiB;AACxE;AAaO,SAASS,kBACd,2BAA2B,GAC3BZ,GAAW,EACXC,OAAqBT,8PAAAA,CAAamB,OAAO;IAEzC,MAAMZ,iBAAiBC,KAAKC,MAAMV,6QAAAA,CAAmBsB,iBAAiB;AACxE;AAUO,SAASC,wBAAwBV,KAAc;IACpD,IAAI,KAACX,iQAAAA,EAAgBW,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAME,MAAM,CAACS,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAASC,yBAAyBd,KAAoB;IAC3D,IAAI,KAACX,iQAAAA,EAAgBW,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAME,MAAM,CAACS,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASI,+BAA+Bf,KAAoB;IACjE,IAAI,KAACX,iQAAAA,EAAgBW,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOe,OAAOhB,MAAME,MAAM,CAACS,KAAK,CAAC,KAAKM,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DYNAMIC_ERROR_CODE","DynamicServerError","Error","constructor","description","digest","isDynamicServerError","err"],"mappings":";;;;;;AAAA,MAAMA,qBAAqB;AAEpB,MAAMC,2BAA2BC;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAC,CAAC,sBAAsB,EAAEA,aAAa,GAAA,IAAA,CADlBA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCL;IAIpC;AACF;AAEO,SAASM,qBAAqBC,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKL;AACxB","ignoreList":[0]}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isHTTPAccessFallbackError","isRedirectError","isNextRouterError","error"],"mappings":";;;;AAAA,SACEA,yBAAyB,QAEpB,8CAA6C;AACpD,SAASC,eAAe,QAA4B,mBAAkB;;;AAO/D,SAASC,kBACdC,KAAc;IAEd,WAAOF,iQAAAA,EAAgBE,cAAUH,kTAAAA,EAA0BG;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["NEXT_STATIC_GEN_BAILOUT","StaticGenBailoutError","Error","code","isStaticGenBailoutError","error"],"mappings":";;;;;;AAAA,MAAMA,0BAA0B;AAEzB,MAAMC,8BAA8BC;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOH;;AACzB;AAEO,SAASI,wBACdC,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMF,IAAI,KAAKH;AACxB","ignoreList":[0]}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n"],"names":["computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","NEXT_RSC_UNION_QUERY","setCacheBustingSearchParam","url","headers","uniqueCacheKey","setCacheBustingSearchParamWithHash","hash","existingSearch","search","rawQuery","startsWith","slice","pairs","split","filter","pair","length","push","join"],"mappings":";;;;;;AAEA,SAASA,8BAA8B,QAAQ,8DAA6D;AAC5G,SACEC,2BAA2B,EAC3BC,mCAAmC,EACnCC,6BAA6B,EAC7BC,QAAQ,EACRC,oBAAoB,QACf,wBAAuB;AAT9B;;;AA4BO,MAAMC,6BAA6B,CACxCC,KACAC;IAEA,MAAMC,qBAAiBT,8SAAAA,EACrBQ,OAAO,CAACP,oRAAAA,CAA4B,EACpCO,OAAO,CAACN,4RAAAA,CAAoC,EAC5CM,OAAO,CAACL,sRAAAA,CAA8B,EACtCK,OAAO,CAACJ,iQAAAA,CAAS;IAEnBM,mCAAmCH,KAAKE;AAC1C,EAAC;AAkBM,MAAMC,qCAAqC,CAChDH,KACAI;IAEA;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBL,IAAIM,MAAM;IACjC,MAAMC,WAAWF,eAAeG,UAAU,CAAC,OACvCH,eAAeI,KAAK,CAAC,KACrBJ;IAEJ,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAMK,QAAQH,SACXI,KAAK,CAAC,KACNC,MAAM,CAAC,CAACC,OAASA,QAAQ,CAACA,KAAKL,UAAU,CAAC,GAAGV,6QAAAA,CAAqB,CAAC,CAAC;IAEvE,IAAIM,KAAKU,MAAM,GAAG,GAAG;QACnBJ,MAAMK,IAAI,CAAC,GAAGjB,6QAAAA,CAAqB,CAAC,EAAEM,MAAM;IAC9C,OAAO;QACLM,MAAMK,IAAI,CAAC,GAAGjB,6QAAAA,EAAsB;IACtC;IACAE,IAAIM,MAAM,GAAGI,MAAMI,MAAM,GAAG,CAAC,CAAC,EAAEJ,MAAMM,IAAI,CAAC,MAAM,GAAG;AACtD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/match-segments.ts"],"sourcesContent":["import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n"],"names":["matchSegment","existingSegment","segment"],"mappings":";;;;AAEO,MAAMA,eAAe,CAC1BC,iBACAC;IAEA,oCAAoC;IACpC,IAAI,OAAOD,oBAAoB,UAAU;QACvC,IAAI,OAAOC,YAAY,UAAU;YAC/B,wCAAwC;YACxC,OAAOD,oBAAoBC;QAC7B;QACA,OAAO;IACT;IAEA,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAO;IACT;IACA,OAAOD,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE,IAAID,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE;AAC/E,EAAC","ignoreList":[0]}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["HTTP_ERROR_FALLBACK_ERROR_CODE","DIGEST","notFound","error","Error","digest"],"mappings":";;;;AAAA,SACEA,8BAA8B,QAEzB,8CAA6C;;AAEpD;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAS,GAAGD,uTAAAA,CAA+B,IAAI,CAAC;AAE/C,SAASE;IACd,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0]}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/builtin/default.tsx"],"sourcesContent":["import { notFound } from '../not-found'\n\nexport const PARALLEL_ROUTE_DEFAULT_PATH =\n  'next/dist/client/components/builtin/default.js'\n\nexport default function ParallelRouteDefault() {\n  notFound()\n}\n"],"names":["notFound","PARALLEL_ROUTE_DEFAULT_PATH","ParallelRouteDefault"],"mappings":";;;;;;AAAA,SAASA,QAAQ,QAAQ,eAAc;;AAEhC,MAAMC,8BACX,iDAAgD;AAEnC,SAASC;QACtBF,qPAAAA;AACF","ignoreList":[0]}},
    {"offset": {"line": 470, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_REFRESH","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_SERVER_PATCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","PrefetchKind"],"mappings":";;;;;;;;;;;;;;;;AAOO,MAAMA,iBAAiB,UAAS;AAChC,MAAMC,kBAAkB,WAAU;AAClC,MAAMC,iBAAiB,UAAS;AAChC,MAAMC,sBAAsB,eAAc;AAC1C,MAAMC,qBAAqB,cAAa;AACxC,MAAMC,uBAAuB,gBAAe;AA4I5C,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA;MAIX","ignoreList":[0]}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;;AAAO,SAASA,kBACdC,GAA8C,EAC9CC,cAAuB,IAAI;IAE3B,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0]}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/use-action-queue.ts"],"sourcesContent":["import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n"],"names":["React","use","useMemo","isThenable","dispatch","dispatchAppRouterAction","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","useActionQueue","actionQueue","state","setState","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","then","asyncState","push","_debugInfo","set"],"mappings":";;;;;;AACA,OAAOA,SAASC,GAAG,EAAEC,OAAO,QAAQ,QAAO;AAC3C,SAASC,UAAU,QAAQ,+BAA8B;;;AAQzD,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEzC,SAASC,wBAAwBC,MAAsB;IAC5D,IAAIF,aAAa,MAAM;QACrB,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAH,SAASE;AACX;AAEA,MAAME,UAAUC,QAAQC,GAAG,CAACC,QAAQ,gCAAK;AACzC,MAAMC,wBAGFJ,uCAAU,IAAIK,YAAa;AAExB,SAASC,eACdC,WAAiC;IAEjC,MAAM,CAACC,OAAOC,SAAS,GAAGjB,mOAAAA,CAAMkB,QAAQ,CAAeH,YAAYC,KAAK;IAExE,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,IAAIP,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEQ,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjCf,WAAW,CAACE;YACVe,yBAAyB;gBACvBN,YAAYX,QAAQ,CAACE,QAAQW;YAC/B;QACF;IACF,OAAO;;IAKP,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,4EAA4E;IAC5E,yBAAyB;IACzB,MAAMK,yBAAqBpB,mOAAAA,EAAQ;QACjC,IAAI,CAACM,SAAS;;QAId,QAAIL,kPAAAA,EAAWa,QAAQ;YACrB,8EAA8E;YAC9E,kFAAkF;YAClF,IAAIO,uBAAuBX,sBAAsBY,GAAG,CAACR;YACrD,IAAIO,yBAAyBE,WAAW;gBACtC,MAAMC,YAA4B,EAAE;gBACpCH,uBAAuBI,QAAQC,OAAO,CAACZ,OAAOa,IAAI,CAAC,CAACC;oBAClD,IAAIA,WAAWJ,SAAS,KAAK,MAAM;wBACjCA,UAAUK,IAAI,IAAID,WAAWJ,SAAS;oBACxC;oBACA,OAAOI;gBACT;gBACAP,qBAAqBS,UAAU,GAAGN;gBAElCd,sBAAsBqB,GAAG,CAACjB,OAAOO;YACnC;YAEA,OAAOA;QACT;QACA,OAAOP;IACT,GAAG;QAACA;KAAM;IAEV,WAAOb,kPAAAA,EAAWmB,0BACdrB,+NAAAA,EAAIqB,sBACJA;AACN","ignoreList":[0]}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/app-router-announcer.tsx"],"sourcesContent":["import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../shared/lib/app-router-types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n"],"names":["useEffect","useRef","useState","createPortal","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","AppRouterAnnouncer","tree","portalNode","setPortalNode","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","undefined","currentTitle","title","pageHeader","querySelector","innerText","textContent","current"],"mappings":";;;;AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,QAAO;AACnD,SAASC,YAAY,QAAQ,YAAW;;;AAGxC,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;IACP,MAAMC,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,mBAAmBG,YAAYC,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEO,SAASS,mBAAmB,EAAEC,IAAI,EAA+B;IACtE,MAAM,CAACC,YAAYC,cAAc,OAAG1B,oOAAAA,EAA6B;QAEjEF,qOAAAA,EAAU;QACR,MAAMgB,YAAYV;QAClBsB,cAAcZ;QACd,OAAO;YACL,MAAMJ,YAAYJ,SAASqB,oBAAoB,CAACzB,eAAe,CAAC,EAAE;YAClE,IAAIQ,WAAWkB,aAAa;gBAC1BtB,SAASgB,IAAI,CAACO,WAAW,CAACnB;YAC5B;QACF;IACF,GAAG,EAAE;IAEL,MAAM,CAACoB,mBAAmBC,qBAAqB,OAAG/B,oOAAAA,EAAS;IAC3D,MAAMgC,oBAAgBjC,kOAAAA,EAA2BkC;QAEjDnC,qOAAAA,EAAU;QACR,IAAIoC,eAAe;QACnB,IAAI5B,SAAS6B,KAAK,EAAE;YAClBD,eAAe5B,SAAS6B,KAAK;QAC/B,OAAO;YACL,MAAMC,aAAa9B,SAAS+B,aAAa,CAAC;YAC1C,IAAID,YAAY;gBACdF,eAAeE,WAAWE,SAAS,IAAIF,WAAWG,WAAW,IAAI;YACnE;QACF;QAEA,4EAA4E;QAC5E,iCAAiC;QACjC,IACEP,cAAcQ,OAAO,KAAKP,aAC1BD,cAAcQ,OAAO,KAAKN,cAC1B;YACAH,qBAAqBG;QACvB;QACAF,cAAcQ,OAAO,GAAGN;IAC1B,GAAG;QAACV;KAAK;IAET,OAAOC,aAAAA,WAAAA,OAAaxB,+OAAAA,EAAa6B,mBAAmBL,cAAc;AACpE","ignoreList":[0]}},
    {"offset": {"line": 664, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/readonly-url-search-params.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n"],"names":["ReadonlyURLSearchParamsError","Error","constructor","ReadonlyURLSearchParams","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA;;;;CAIC,GAED,cAAc;;;;AACd,MAAMA,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAMO,MAAMC,gCAAgCC;IAC3C,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,SAAS;QACP,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,MAAM;QACJ,MAAM,IAAIP;IACZ;IACA,wKAAwK,GACxKQ,OAAO;QACL,MAAM,IAAIR;IACZ;AACF","ignoreList":[0]}},
    {"offset": {"line": 695, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unrecognized-action-error.ts"],"sourcesContent":["export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n"],"names":["UnrecognizedActionError","Error","constructor","args","name","unstable_isUnrecognizedActionError","error"],"mappings":";;;;;;AAAO,MAAMA,gCAAgCC;IAC3CC,YAAY,GAAGC,IAAyC,CAAE;QACxD,KAAK,IAAIA;QACT,IAAI,CAACC,IAAI,GAAG;IACd;AACF;AAoBO,SAASC,mCACdC,KAAc;IAEd,OAAO,CAAC,CACNA,CAAAA,SACA,OAAOA,UAAU,YACjBA,iBAAiBN,uBAAsB;AAE3C","ignoreList":[0]}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["HTTP_ERROR_FALLBACK_ERROR_CODE","DIGEST","forbidden","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;;AAAA,SACEA,8BAA8B,QAEzB,8CAA6C;;AAEpD,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAS,GAAGD,uTAAAA,CAA+B,IAAI,CAAC;AAE/C,SAASE;IACd,IAAI,CAACC,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["HTTP_ERROR_FALLBACK_ERROR_CODE","DIGEST","unauthorized","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;;AAAA,SACEA,8BAA8B,QAEzB,8CAA6C;;AAEpD,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAS,GAAGD,uTAAAA,CAA+B,IAAI,CAAC;AAE/C,SAASE;IACd,IAAI,CAACC,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 793, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["isHangingPromiseRejectionError","isPostpone","isBailoutToCSRError","isNextRouterError","isDynamicPostpone","isPrerenderInterruptedError","isDynamicServerError","unstable_rethrow","error","Error","cause"],"mappings":";;;;AAAA,SAASA,8BAA8B,QAAQ,uCAAsC;AACrF,SAASC,UAAU,QAAQ,4CAA2C;AACtE,SAASC,mBAAmB,QAAQ,+CAA8C;AAClF,SAASC,iBAAiB,QAAQ,yBAAwB;AAC1D,SACEC,iBAAiB,EACjBC,2BAA2B,QACtB,4CAA2C;AAClD,SAASC,oBAAoB,QAAQ,yBAAwB;;;;;;;AAEtD,SAASC,iBAAiBC,KAAc;IAC7C,QACEL,+QAAAA,EAAkBK,cAClBN,oRAAAA,EAAoBM,cACpBF,+QAAAA,EAAqBE,cACrBJ,yQAAAA,EAAkBI,cAClBP,qQAAAA,EAAWO,cACXR,8QAAAA,EAA+BQ,cAC/BH,mRAAAA,EAA4BG,QAC5B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBC,SAAS,WAAWD,OAAO;QAC9CD,iBAAiBC,MAAME,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 821, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC,GACD;;;;AAAO,MAAMA,mBACX,OAAOC,WAAW,qBAEZC,QAAQ,wKACRF,gBAAgB,GAEhBE,QAAQ,8BACRF,gBAAgB,CAAA","ignoreList":[0]}},
    {"offset": {"line": 836, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","unstable_isUnrecognizedActionError","Error","redirect","permanentRedirect","RedirectType","notFound","forbidden","unauthorized","unstable_rethrow"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,+BAA8B;AAQtE,SAASG,QAAQ,EAAEC,iBAAiB,QAAQ,aAAY;AACxD,SAASC,YAAY,QAAQ,mBAAkB;AAC/C,SAASC,QAAQ,QAAQ,cAAa;AACtC,SAASC,SAAS,QAAQ,cAAa;AACvC,SAASC,YAAY,QAAQ,iBAAgB;AAC7C,SAASC,gBAAgB,QAAQ,qBAAoB;;AAX9C,SAASR;IACd,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0]}},
    {"offset": {"line": 867, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/navigation.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n"],"names":["React","useContext","useMemo","use","AppRouterContext","LayoutRouterContext","SearchParamsContext","PathnameContext","PathParamsContext","NavigationPromisesContext","computeSelectedLayoutSegment","getSelectedLayoutSegmentPath","ReadonlyURLSearchParams","useDynamicRouteParams","window","require","undefined","useDynamicSearchParams","useSearchParams","searchParams","readonlySearchParams","process","env","NODE_ENV","navigationPromises","usePathname","pathname","ServerInsertedHTMLContext","useServerInsertedHTML","useRouter","router","Error","useParams","params","useSelectedLayoutSegments","parallelRouteKey","context","promise","selectedLayoutSegmentsPromises","get","parentTree","useSelectedLayoutSegment","selectedLayoutSegments","selectedLayoutSegmentPromises","unstable_isUnrecognizedActionError","notFound","forbidden","unauthorized","redirect","permanentRedirect","RedirectType","unstable_rethrow"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1001, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect-boundary.tsx"],"sourcesContent":["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],"names":["React","useEffect","useRouter","getRedirectTypeFromError","getURLFromRedirectError","RedirectType","isRedirectError","HandleRedirect","redirect","reset","redirectType","router","startTransition","push","replace","RedirectErrorBoundary","Component","constructor","props","state","getDerivedStateFromError","error","url","render","setState","children","RedirectBoundary"],"mappings":";;;;;;;AACA,OAAOA,SAASC,SAAS,QAAQ,QAAO;AAExC,SAASC,SAAS,QAAQ,eAAc;AACxC,SAASC,wBAAwB,EAAEC,uBAAuB,QAAQ,aAAY;AAC9E,SAASC,YAAY,EAAEC,eAAe,QAAQ,mBAAkB;AALhE;;;;;;AAYA,SAASC,eAAe,EACtBC,QAAQ,EACRC,KAAK,EACLC,YAAY,EAKb;IACC,MAAMC,SAAST,wQAAAA;IAEfD,yOAAAA,EAAU;QACRD,mOAAAA,CAAMY,eAAe,CAAC;YACpB,IAAIF,iBAAiBL,8PAAAA,CAAaQ,IAAI,EAAE;gBACtCF,OAAOE,IAAI,CAACL,UAAU,CAAC;YACzB,OAAO;gBACLG,OAAOG,OAAO,CAACN,UAAU,CAAC;YAC5B;YACAC;QACF;IACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;KAAO;IAE1C,OAAO;AACT;AAEO,MAAMI,8BAA8Bf,mOAAAA,CAAMgB,SAAS;IAIxDC,YAAYC,KAA4B,CAAE;QACxC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEX,UAAU;YAAME,cAAc;QAAK;IACpD;IAEA,OAAOU,yBAAyBC,KAAU,EAAE;QAC1C,QAAIf,iQAAAA,EAAgBe,QAAQ;YAC1B,MAAMC,UAAMlB,gQAAAA,EAAwBiB;YACpC,MAAMX,mBAAeP,iQAAAA,EAAyBkB;YAC9C,IAAI,aAAaA,OAAO;gBACtB,yEAAyE;gBACzE,gFAAgF;gBAChF,eAAe;gBACf,OAAO;oBAAEb,UAAU;oBAAME,cAAc;gBAAK;YAC9C;YAEA,OAAO;gBAAEF,UAAUc;gBAAKZ;YAAa;QACvC;QACA,wCAAwC;QACxC,MAAMW;IACR;IAEA,yIAAyI;IACzIE,SAA0B;QACxB,MAAM,EAAEf,QAAQ,EAAEE,YAAY,EAAE,GAAG,IAAI,CAACS,KAAK;QAC7C,IAAIX,aAAa,QAAQE,iBAAiB,MAAM;YAC9C,OAAA,WAAA,OACE,wOAAA,EAACH,gBAAAA;gBACCC,UAAUA;gBACVE,cAAcA;gBACdD,OAAO,IAAM,IAAI,CAACe,QAAQ,CAAC;wBAAEhB,UAAU;oBAAK;;QAGlD;QAEA,OAAO,IAAI,CAACU,KAAK,CAACO,QAAQ;IAC5B;AACF;AAEO,SAASC,iBAAiB,EAAED,QAAQ,EAAiC;IAC1E,MAAMd,aAAST,oQAAAA;IACf,OAAA,WAAA,OACE,wOAAA,EAACa,uBAAAA;QAAsBJ,QAAQA;kBAASc;;AAE5C","ignoreList":[0]}},
    {"offset": {"line": 1092, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["PAGE_SEGMENT_KEY","createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith"],"mappings":";;;;AACA,SAASA,gBAAgB,QAAQ,8BAA6B;;AAEvD,SAASC,qBACdC,OAAgB,EAChBC,0BAAmC,KAAK;IAExC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAO,GAAGA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,EAAE;IACpD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACN,iPAAAA,GAAmB;QACnE,OAAOA,iPAAAA;IACT;IAEA,OAAOE;AACT","ignoreList":[0]}},
    {"offset": {"line": 1115, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n"],"names":["DEFAULT_SEGMENT_KEY","createRouterCacheKey","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","segment","childParallelRoutes","childSegmentMap","get","cacheKey","cacheKeyWithoutSearchParams","cacheNode","item"],"mappings":";;;;AAIA,SAASA,mBAAmB,QAAQ,iCAAgC;AACpE,SAASC,oBAAoB,QAAQ,6BAA4B;;;AAE1D,SAASC,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,KAAK,MAAMD,OAAOF,mBAAoB;QACpC,MAAM,CAACI,SAASC,oBAAoB,GAAGb,cAAc,CAACU,IAAI;QAC1D,gEAAgE;QAChE,mCAAmC;QACnC,IAAIE,YAAYhB,oPAAAA,EAAqB;YACnC;QACF;QACA,MAAMkB,kBAAkBf,MAAMC,cAAc,CAACe,GAAG,CAACL;QACjD,IAAI,CAACI,iBAAiB;YACpB;QACF;QAEA,MAAME,eAAWnB,0SAAAA,EAAqBe;QACtC,MAAMK,kCAA8BpB,0SAAAA,EAAqBe,SAAS;QAElE,MAAMM,YAAYJ,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACE,WAAW;YACd;QACF;QAEA,MAAMC,OAAOlB,oBACXiB,WACAL,qBACAX,YAAY,MAAMc,UAClBd,YAAY,MAAMe;QAGpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1171, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unresolved-thenable.ts"],"sourcesContent":["/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n"],"names":["unresolvedThenable","then"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,MAAMA,qBAAqB;IAChCC,MAAM,KAAO;AACf,EAAsB","ignoreList":[0]}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/has-base-path.ts"],"sourcesContent":["import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n"],"names":["pathHasPrefix","basePath","process","env","__NEXT_ROUTER_BASEPATH","hasBasePath","path"],"mappings":";;;;AAAA,SAASA,aAAa,QAAQ,6CAA4C;;AAE1E,MAAMC,WAAYC,QAAQC,GAAG,CAACC,sBAAsB,MAAe;AAE5D,SAASC,YAAYC,IAAY;IACtC,WAAON,+QAAAA,EAAcM,MAAML;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 1198, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/remove-base-path.ts"],"sourcesContent":["import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n"],"names":["hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","removeBasePath","path","__NEXT_MANUAL_CLIENT_BASE_PATH","length","slice","startsWith"],"mappings":";;;;AAAA,SAASA,WAAW,QAAQ,kBAAiB;;AAE7C,MAAMC,WAAYC,QAAQC,GAAG,CAACC,sBAAsB,MAAe;AAE5D,SAASC,eAAeC,IAAY;IACzC,IAAIJ,QAAQC,GAAG,CAACI,8BAA8B,EAAE;;IAMhD,iDAAiD;IACjD,IAAIN,SAASO,MAAM,KAAK,GAAG,OAAOF;IAElCA,OAAOA,KAAKG,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACF,KAAKI,UAAU,CAAC,MAAMJ,OAAO,CAAC,CAAC,EAAEA,MAAM;IAC5C,OAAOA;AACT","ignoreList":[0]}},
    {"offset": {"line": 1218, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","extractPathFromFlightRouterState","flightRouterState","Array","isArray","some","m","startsWith","undefined","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","computeChangedPath","split","getSelectedParams","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/nav-failure-handler.ts"],"sourcesContent":["import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n"],"names":["useEffect","createHrefFromUrl","handleHardNavError","error","window","next","__pendingUrl","URL","location","href","console","toString","useNavFailureHandler","process","env","__NEXT_APP_NAV_FAIL_HANDLING","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener"],"mappings":";;;;;;AAAA,SAASA,SAAS,QAAQ,QAAO;AACjC,SAASC,iBAAiB,QAAQ,wCAAuC;;;AAElE,SAASC,mBAAmBC,KAAc;IAC/C,IACEA,SACA,OAAOC,2CAAW,eAClBA,OAAOC,IAAI,CAACC,YAAY,QACxBL,oSAAAA,EAAkB,IAAIM,IAAIH,OAAOI,QAAQ,CAACC,IAAI,WAC5CR,oSAAAA,EAAkBG,OAAOC,IAAI,CAACC,YAAY,GAC5C;;IAQF,OAAO;AACT;AAEO,SAASM;IACd,IAAIC,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;AAwBhD","ignoreList":[0]}},
    {"offset": {"line": 1350, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/handle-mutable.ts"],"sourcesContent":["import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n"],"names":["computeChangedPath","isNotUndefined","value","handleMutable","state","mutable","shouldScroll","previousNextUrl","nextUrl","patchedTree","changedPath","tree","canonicalUrl","renderedSearch","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","debugInfo","collectedDebugInfo"],"mappings":";;;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;;AAO3D,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASC,cACdC,KAA2B,EAC3BC,OAAgB;IAEhB,0DAA0D;IAC1D,MAAMC,eAAeD,QAAQC,YAAY,IAAI;IAE7C,IAAIC,kBAAkBH,MAAMG,eAAe;IAC3C,IAAIC,UAAUJ,MAAMI,OAAO;IAE3B,IAAIP,eAAeI,QAAQI,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,kBAAcV,kSAAAA,EAAmBI,MAAMO,IAAI,EAAEN,QAAQI,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDH,kBAAkBC;YAClBA,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUJ,MAAMQ,YAAY;QAC9B;IACA,0EAA0E;IAC5E;IAEA,OAAO;QACL,YAAY;QACZA,cAAcP,QAAQO,YAAY,IAAIR,MAAMQ,YAAY;QACxDC,gBAAgBR,QAAQQ,cAAc,IAAIT,MAAMS,cAAc;QAC9DC,SAAS;YACPC,aAAad,eAAeI,QAAQU,WAAW,IAC3CV,QAAQU,WAAW,GACnBX,MAAMU,OAAO,CAACC,WAAW;YAC7BC,eAAef,eAAeI,QAAQW,aAAa,IAC/CX,QAAQW,aAAa,GACrBZ,MAAMU,OAAO,CAACE,aAAa;YAC/BC,4BAA4BhB,eAC1BI,QAAQY,0BAA0B,IAEhCZ,QAAQY,0BAA0B,GAClCb,MAAMU,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOb,eACHL,eAAeI,SAASe,sBACtB,OACAhB,MAAMc,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBhB,QAAQgB,cAAc,IAAI;YAC1CC,cAAchB,eAEV,AACAD,QAAQiB,YAAY,IAAIjB,QAAQiB,IADI,QACQ,KAAK,KAE/CC,mBAAmBlB,QAAQiB,YAAY,CAACE,KAAK,CAAC,MAC9CpB,MAAMc,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAcnB,eACTD,SAASe,sBAAsBhB,MAAMc,iBAAiB,CAACO,YAAY,GAEpE,EAAE;QACR;QACA,eAAe;QACfC,OAAOrB,QAAQqB,KAAK,GAAGrB,QAAQqB,KAAK,GAAGtB,MAAMsB,KAAK;QAClD,8BAA8B;QAC9Bf,MAAMV,eAAeI,QAAQI,WAAW,IACpCJ,QAAQI,WAAW,GACnBL,MAAMO,IAAI;QACdH;QACAD,iBAAiBA;QACjBoB,WAAWtB,QAAQuB,kBAAkB,IAAI;IAC3C;AACF","ignoreList":[0]}},
    {"offset": {"line": 1406, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/app-call-server.ts"],"sourcesContent":["import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n"],"names":["startTransition","ACTION_SERVER_ACTION","dispatchAppRouterAction","callServer","actionId","actionArgs","Promise","resolve","reject","type"],"mappings":";;;;AAAA,SAASA,eAAe,QAAQ,QAAO;AACvC,SAASC,oBAAoB,QAAQ,mDAAkD;AACvF,SAASC,uBAAuB,QAAQ,gCAA+B;;;;AAEhE,eAAeC,WAAWC,QAAgB,EAAEC,UAAiB;IAClE,OAAO,IAAIC,QAAQ,CAACC,SAASC;YAC3BR,2OAAAA,EAAgB;gBACdE,8QAAAA,EAAwB;gBACtBO,MAAMR,oSAAAA;gBACNG;gBACAC;gBACAE;gBACAC;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1433, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/app-find-source-map-url.ts"],"sourcesContent":["const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n"],"names":["basePath","process","env","__NEXT_ROUTER_BASEPATH","pathname","findSourceMapURL","NODE_ENV","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined"],"mappings":";;;;AAAA,MAAMA,WAAWC,QAAQC,GAAG,CAACC,sBAAsB,MAAI;AACvD,MAAMC,WAAW,GAAGJ,SAAS,oBAAoB,CAAC;AAE3C,MAAMK,mBACXJ,QAAQC,GAAG,CAACI,QAAQ,KAAK,cACrB,SAASD,iBAAiBE,QAAgB;IACxC,IAAIA,aAAa,IAAI;QACnB,OAAO;IACT;IAEA,IACEA,SAASC,UAAU,CAACC,SAASC,QAAQ,CAACC,MAAM,KAC5CJ,SAASK,QAAQ,CAAC,kBAClB;QACA,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAO,GAAGL,SAAS,IAAI,CAAC;IAC1B;IAEA,MAAMM,MAAM,IAAIC,IAAIV,UAAUK,SAASC,QAAQ,CAACC,MAAM;IACtDE,IAAIE,YAAY,CAACC,GAAG,CAAC,YAAYT;IAEjC,OAAOM,IAAII,IAAI;AACjB,IACAC,UAAS","ignoreList":[0]}},
    {"offset": {"line": 1461, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/route-params.ts"],"sourcesContent":["import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n"],"names":["addSearchParamsIfPageSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","ROOT_SEGMENT_REQUEST_KEY","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_RSC_UNION_QUERY","getRenderedSearch","response","rewrittenQuery","headers","get","urlToUrlWithoutFlightMarker","URL","url","search","getRenderedPathname","rewrittenPath","pathname","parseDynamicParamFromURLPart","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","prefix","i","doesStaticSegmentAppearInURL","segment","startsWith","endsWith","getCacheKeyForDynamicParam","paramValue","renderedSearch","pageSegmentWithSearchParams","Object","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","getParamValueFromCacheKey","paramCacheKey","isCatchAll","split","urlSearchParamsToParsedUrlQuery","result","key","value","entries","undefined","Array","isArray","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1656, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/flight-data-helpers.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n"],"names":["PAGE_SEGMENT_KEY","getCacheKeyForDynamicParam","parseDynamicParamFromURLPart","doesStaticSegmentAppearInURL","getRenderedPathname","getRenderedSearch","createHrefFromUrl","getFlightDataPartsFromPath","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","createInitialRSCPayloadFromFallbackPrerender","response","fallbackInitialRSCPayload","renderedPathname","renderedSearch","canonicalUrl","URL","location","href","originalFlightDataPath","f","originalFlightRouterState","b","c","split","q","i","fillInFallbackFlightRouterState","m","G","S","flightRouterState","pathnameParts","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","paramName","paramType","paramValue","cacheKey","childPathnamePartsIndex","children","newChildren","key","childFlightRouterState","newState","getNextFlightSegmentPath","flightSegmentPath","normalizeFlightData","flightData","map","prepareFlightRouterStateForRequest","isHmrRefresh","encodeURIComponent","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","Object","entries","result","shouldPreserveRefreshMarker","undefined","startsWith","Boolean"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1852, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/app-build-id.ts"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n"],"names":["globalBuildId","setAppBuildId","buildId","getAppBuildId"],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AAEtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;;;;;;;AAC7E,IAAIA,gBAAwB;AAErB,SAASC,cAAcC,OAAe;IAC3CF,gBAAgBE;AAClB;AAEO,SAASC;IACd,OAAOH;AACT","ignoreList":[0]}},
    {"offset": {"line": 1881, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      fetchPriority,\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","callServer","findSourceMapURL","PrefetchKind","normalizeFlightData","prepareFlightRouterStateForRequest","getAppBuildId","setCacheBustingSearchParam","getRenderedSearch","urlToUrlWithoutFlightMarker","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","doMpaNavigation","url","URL","location","origin","toString","isPageUnloading","window","addEventListener","fetchServerResponse","options","flightRouterState","nextUrl","prefetchKind","headers","isHmrRefresh","AUTO","originalUrl","fetchPriority","TEMPORARY","__NEXT_CONFIG_OUTPUT","pathname","endsWith","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","createFetch","responseUrl","canonicalUrl","redirected","contentType","get","interception","includes","postponed","staleTimeHeaderSeconds","staleTime","parseInt","isFlightResponse","startsWith","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","createFromNextReadableStream","b","normalizedFlightData","f","flightData","renderedSearch","couldBeIntercepted","prerendered","S","debugInfo","_debugInfo","err","console","error","signal","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","self","__next_r","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","undefined","fetchUrl","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","searchParams","delete","rscResponse","href","status","requestHeaders","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2165, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild"],"mappings":";;;;AAEO,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,oEAAoE;IACpE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD","ignoreList":[0]}},
    {"offset": {"line": 2206, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment  a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation  but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldUrl,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[0]\n    loading = prefetchData[2]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[3]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): Task {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (result: FetchServerResponseResult) => {\n      if (typeof result === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      const { flightData, debugInfo } = result\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead,\n          debugInfo\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null, debugInfo)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error, null)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    debugInfo\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading:\n      prefetchData !== null\n        ? (prefetchData[2] ?? null)\n        : // If we don't have a prefetch, then we don't know if there's a loading component.\n          // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n          createDeferredRsc<LoadingModuleData>(),\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead,\n            debugInfo\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nexport function abortTask(\n  task: SPANavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error, debugInfo)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n"],"names":["DEFAULT_SEGMENT_KEY","matchSegment","createHrefFromUrl","createRouterCacheKey","isNavigatingToNewRootLayout","DYNAMIC_STALETIME_MS","MPA_NAVIGATION_TASK","route","node","dynamicRequestTree","children","startPPRNavigation","navigatedAt","oldUrl","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","segmentPath","updateCacheNodeOnNavigation","didFindRootLayout","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","isRootLayout","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","needsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentPathChild","concat","newSegmentKeyChild","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","reuseActiveSegmentInDefaultSlot","beginRenderingNewRouteTree","Object","keys","length","set","newCacheNodeChild","newSegmentMapChild","taskChildRoute","dynamicRequestTreeChild","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","createCacheNodeOnNavigation","routerState","routerStateChildren","isLeafSegment","cacheNodeNavigatedAt","isPrefetchRscPartial","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","push","routerStateChild","existingSegmentMapChild","segmentChild","segmentPathChild","segmentKeyChild","existingCacheNodeChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","reusedRouterState","oldRefreshMarker","listenForDynamicRequest","task","responsePromise","then","result","flightData","debugInfo","normalizedFlightData","tree","serverRouterState","seedData","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","size","maybePrefetchRsc","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","dynamicLoading","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","_debugInfo"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3061, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/types.ts"],"sourcesContent":["/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n"],"names":["NavigationResultTag","PrefetchPriority","FetchStrategy"],"mappings":"AAAA;;CAEC,GAED;;;;;;;;AAAO,IAAWA,sBAAAA,WAAAA,GAAAA,SAAAA,mBAAAA;;;;;WAAAA;MAKjB;AAKM,IAAWC,mBAAAA,WAAAA,GAAAA,SAAAA,gBAAAA;IAChB;;;;;GAKC,GAAA,gBAAA,CAAA,gBAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IAED;;GAEC,GAAA,gBAAA,CAAA,gBAAA,CAAA,UAAA,GAAA,EAAA,GAAA;IAED;;;GAGC,GAAA,gBAAA,CAAA,gBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;WAfeA;MAiBjB;AAEM,IAAWC,gBAAAA,WAAAA,GAAAA,SAAAA,aAAAA;IAChB,6DAA6D;IAC7D,+DAA+D;IAC/D,mDAAmD;;;;;WAHnCA;MAQjB","ignoreList":[0]}},
    {"offset": {"line": 3108, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/lru.ts"],"sourcesContent":["import type { MapEntry } from './cache-map'\nimport { deleteFromCacheMap } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\n// The MapEntry type is used as an LRU node, too. We choose this one instead of\n// the inner cache entry type (RouteCacheEntry, SegmentCacheEntry) because it's\n// monomorphic and can be optimized by the VM.\ntype LRUNode = MapEntry<any>\n\nlet head: LRUNode | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: LRUNode) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: LRUNode, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: LRUNode) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteFromCacheMap(tail.value)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n"],"names":["deleteFromCacheMap","head","didScheduleCleanup","lruSize","maxLruSize","lruPut","node","prev","next","size","ensureCleanupIsScheduled","tail","updateLruSize","newNodeSize","prevNodeSize","deleteFromLru","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","value","requestIdleCallback","cb","setTimeout"],"mappings":";;;;;;;;AACA,SAASA,kBAAkB,QAAQ,cAAa;;AAUhD,IAAIC,OAAuB;AAC3B,IAAIC,qBAA8B;AAClC,IAAIC,UAAkB;AAEtB,+EAA+E;AAC/E,0EAA0E;AAC1E,4CAA4C;AAC5C,MAAMC,aAAa,KAAK,OAAO,KAAK,QAAQ;;AAErC,SAASC,OAAOC,IAAa;IAClC,IAAIL,SAASK,MAAM;QACjB,sBAAsB;QACtB;IACF;IACA,MAAMC,OAAOD,KAAKC,IAAI;IACtB,MAAMC,OAAOF,KAAKE,IAAI;IACtB,IAAIA,SAAS,QAAQD,SAAS,MAAM;QAClC,uBAAuB;QACvBJ,WAAWG,KAAKG,IAAI;QACpB,mEAAmE;QACnE,yEAAyE;QACzE,wBAAwB;QACxBC;IACF,OAAO;QACL,oDAAoD;QACpDH,KAAKC,IAAI,GAAGA;QACZA,KAAKD,IAAI,GAAGA;IACd;IAEA,gCAAgC;IAChC,IAAIN,SAAS,MAAM;QACjB,0BAA0B;QAC1BK,KAAKC,IAAI,GAAGD;QACZA,KAAKE,IAAI,GAAGF;IACd,OAAO;QACL,+BAA+B;QAC/B,MAAMK,OAAOV,KAAKM,IAAI;QACtBD,KAAKC,IAAI,GAAGI;QACZ,sEAAsE;QACtE,IAAIA,SAAS,MAAM;YACjBA,KAAKH,IAAI,GAAGF;QACd;QACAA,KAAKE,IAAI,GAAGP;QACZA,KAAKM,IAAI,GAAGD;IACd;IACAL,OAAOK;AACT;AAEO,SAASM,cAAcN,IAAa,EAAEO,WAAmB;IAC9D,yEAAyE;IACzE,iEAAiE;IACjE,MAAMC,eAAeR,KAAKG,IAAI;IAC9BH,KAAKG,IAAI,GAAGI;IACZ,IAAIP,KAAKE,IAAI,KAAK,MAAM;QACtB,wDAAwD;QACxD;IACF;IACA,4BAA4B;IAC5BL,UAAUA,UAAUW,eAAeD;IACnCH;AACF;AAEO,SAASK,cAAcC,OAAgB;IAC5C,MAAMR,OAAOQ,QAAQR,IAAI;IACzB,MAAMD,OAAOS,QAAQT,IAAI;IACzB,IAAIC,SAAS,QAAQD,SAAS,MAAM;QAClCJ,WAAWa,QAAQP,IAAI;QAEvBO,QAAQR,IAAI,GAAG;QACfQ,QAAQT,IAAI,GAAG;QAEf,uBAAuB;QACvB,IAAIN,SAASe,SAAS;YACpB,kBAAkB;YAClB,IAAIR,SAASP,MAAM;gBACjB,0BAA0B;gBAC1BA,OAAO;YACT,OAAO;gBACLA,OAAOO;YACT;QACF,OAAO;YACLD,KAAKC,IAAI,GAAGA;YACZA,KAAKD,IAAI,GAAGA;QACd;IACF,OAAO;IACL,kBAAkB;IACpB;AACF;AAEA,SAASG;IACP,IAAIR,sBAAsBC,WAAWC,YAAY;QAC/C;IACF;IACAF,qBAAqB;IACrBe,uBAAuBC;AACzB;AAEA,SAASA;IACPhB,qBAAqB;IAErB,sEAAsE;IACtE,gEAAgE;IAChE,iEAAiE;IACjE,MAAMiB,mBAAmBf,aAAa;IACtC,MAAOD,UAAUgB,oBAAoBlB,SAAS,KAAM;QAClD,MAAMU,OAAOV,KAAKM,IAAI;QACtB,sEAAsE;QACtE,IAAII,SAAS,MAAM;YACjB,mEAAmE;YACnE,WAAW;gBACXX,mRAAAA,EAAmBW,KAAKS,KAAK;QAC/B;IACF;AACF;AAEA,MAAMH,yBACJ,OAAOI,wBAAwB,aAC3BA,sBACA,CAACC,KAAmBC,WAAWD,IAAI","ignoreList":[0]}},
    {"offset": {"line": 3228, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/cache-map.ts"],"sourcesContent":["import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\ntype MapEntryShared<V extends MapValue> = {\n  parent: MapEntry<V> | null\n  key: any\n  map: Map<any, MapEntry<V>> | null\n\n  // LRU-related fields\n  prev: MapEntry<any> | null\n  next: MapEntry<any> | null\n  size: number\n}\n\ntype EmptyMapEntry<V extends MapValue> = MapEntryShared<V> & {\n  value: null\n}\n\ntype FullMapEntry<V extends MapValue> = MapEntryShared<V> & {\n  value: V\n}\n\nexport type MapEntry<V extends MapValue> = EmptyMapEntry<V> | FullMapEntry<V>\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: MapEntry<any> | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: EmptyMapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  value: V\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl<V>(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue<V extends MapValue>(\n  entry: MapEntry<V>,\n  value: V\n): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n\n    // Fill the entry with the updated value.\n    const emptyEntry: EmptyMapEntry<V> = entry as any\n    emptyEntry.value = null\n    fillEmptyReference(emptyEntry, value)\n  } else {\n    fillEmptyReference(entry as any, value)\n  }\n}\n\nfunction fillEmptyReference<V extends MapValue>(\n  entry: EmptyMapEntry<V>,\n  value: V\n): void {\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  const fullEntry: FullMapEntry<V> = entry as any\n  fullEntry.value = value\n  value.ref = fullEntry\n\n  updateLruSize(fullEntry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap<V extends MapValue>(value: V): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef<V extends MapValue>(value: V): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nfunction deleteMapEntry<V extends MapValue>(entry: MapEntry<V>): void {\n  // Delete the entry from the cache.\n  const emptyEntry: EmptyMapEntry<V> = entry as any\n  emptyEntry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = emptyEntry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = emptyEntry.parent\n    let key = emptyEntry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(emptyEntry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n"],"names":["lruPut","updateLruSize","deleteFromLru","Fallback","Revalidation","createCacheMap","cacheMap","parent","key","value","map","prev","next","size","getOrInitialize","keys","isRevalidation","entry","remainingKeys","previousKey","existingEntry","get","undefined","Map","newEntry","set","getFromCacheMap","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","isValueExpired","staleAt","version","lazilyEvictIfNeeded","deleteMapEntry","result","fallbackEntry","setInCacheMap","setMapEntryValue","dropRef","emptyEntry","fillEmptyReference","oldEntry","ref","fullEntry","deleteFromCacheMap","parentMap","delete","revalidatingEntry","setSizeInCacheMap"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3509, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/vary-path.ts"],"sourcesContent":["import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    value: NormalizedPathname\n    parent: {\n      value: NormalizedSearch\n      parent: {\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    value: string\n    parent: {\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    value: requestKey,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it  for example, if the server tells us that the response\n  // doesn't vary on a particular param  but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    value: originalVaryPath.value,\n    parent: {\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n"],"names":["FetchStrategy","Fallback","HEAD_REQUEST_KEY","getRouteVaryPath","pathname","search","nextUrl","varyPath","value","parent","getFulfilledRouteVaryPath","couldBeIntercepted","appendLayoutVaryPath","parentPath","cacheKey","varyPathPart","finalizeLayoutVaryPath","requestKey","layoutVaryPath","finalizePageVaryPath","renderedSearch","pageVaryPath","finalizeMetadataVaryPath","pageRequestKey","getSegmentVaryPathForRequest","fetchStrategy","tree","originalVaryPath","isPage","doesVaryOnSearchParams","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","clonePageVaryPathWithNewSearchParams","newSearch","clonedVaryPath"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3696, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/cache-key.ts"],"sourcesContent":["// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n"],"names":["createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","pathname","search"],"mappings":"AAAA,2DAA2D;;;;;AAmBpD,SAASA,eACdC,YAAoB,EACpBC,OAAsB;IAEtB,MAAMC,cAAc,IAAIC,IAAIH;IAC5B,MAAMI,WAAW;QACfC,UAAUH,YAAYG,QAAQ;QAC9BC,QAAQJ,YAAYI,MAAM;QAC1BL,SAASA;IACX;IACA,OAAOG;AACT","ignoreList":[0]}},
    {"offset": {"line": 3714, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/scheduler.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport { getCurrentCacheVersion } from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization  theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(\n      now,\n      FetchStrategy.PPR,\n      route,\n      route.metadata\n    ),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree  the part that doesn't exist on the current page  we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static  once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch  via <Link prefetch={true}>  implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state  it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response  it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    route,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    route,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        fetchStrategy,\n        route,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in  is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n"],"names":["HasLoadingBoundary","matchSegment","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","EntryStatus","fetchSegmentPrefetchesUsingDynamicRequest","convertRouteTreeToFlightRouterState","readOrCreateRevalidatingSegmentEntry","upsertSegmentEntry","upgradeToPendingSegment","waitForSegmentCacheEntry","overwriteRevalidatingSegmentCacheEntry","canNewFetchStrategyProvideMoreContent","getSegmentVaryPathForRequest","createCacheKey","FetchStrategy","PrefetchPriority","getCurrentCacheVersion","addSearchParamsIfPageSegment","PAGE_SEGMENT_KEY","scheduleMicrotask","queueMicrotask","fn","Promise","resolve","then","catch","error","setTimeout","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","startRevalidationCooldown","clearTimeout","ensureWorkIsScheduled","schedulePrefetchTask","key","treeAtTimeOfPrefetch","fetchStrategy","priority","onInvalidate","task","cacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","cancelPrefetchTask","heapDelete","reschedulePrefetchTask","Intent","heapResift","isPrefetchTaskDirty","nextUrl","tree","currentCacheVersion","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","result","onPrefetchConnectionClosed","closed","value","pingPrefetchTask","now","Date","heapPeek","exitStatus","pingRoute","heapPop","background","route","pingRootRouteTree","search","url","URL","pathname","location","origin","keyWithoutSearch","href","routeWithoutSearch","status","Empty","Pending","Fulfilled","Rejected","staleAt","blockedTasks","Set","add","PPR","isPPREnabled","LoadingBoundary","pingStaticHead","pingSharedPartOfCacheComponentsTree","spawnedEntries","Map","pingRuntimeHead","PPRRuntime","requestTree","pingRuntimePrefetches","needsDynamicRequest","size","Full","dynamicRequestTree","diffRouteTreeAgainstCurrent","pingStaticSegmentData","metadata","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","segment","oldTreeChildren","newTreeChildren","slots","parallelRouteKey","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","undefined","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","hasRuntimePrefetch","requestKey","childTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","hasLoadingBoundary","SubtreeHasNoLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","isRootLayout","refetchMarkerContext","refetchMarker","set","segmentHasLoadingBoundary","SegmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","isPartial","pingFullSegmentRevalidation","has","routeKey","pingPPRSegmentRevalidation","revalidatingSegment","upsertSegmentOnCompletion","pendingSegment","nonEmptyRevalidatingSegment","emptySegment","noop","promise","varyPath","fulfilled","currentSegment","cachedSegment","Object","fromEntries","URLSearchParams","renderedSearch","compareQueuePriority","a","b","priorityDiff","phaseDiff","heap","node","index","length","push","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","parent","i","halfLength","leftIndex","left","rightIndex","right"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4839, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/links.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n"],"names":["FetchStrategy","PrefetchPriority","createCacheKey","schedulePrefetchTask","scheduleSegmentPrefetchTask","cancelPrefetchTask","reschedulePrefetchTask","isPrefetchTaskDirty","startTransition","linkForMostRecentNavigation","PENDING_LINK_STATUS","pending","IDLE_LINK_STATUS","setLinkForCurrentNavigation","link","setOptimisticLinkStatus","unmountLinkForCurrentNavigation","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","get","undefined","unmountPrefetchableInstance","set","observe","coercePrefetchableUrl","href","window","createPrefetchURL","require","reportErrorFn","reportError","console","error","mountLinkInstance","router","fetchStrategy","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","mountFormInstance","delete","unobserve","entries","entry","intersectionRatio","onLinkVisibilityChanged","target","process","env","NODE_ENV","add","rescheduleLinkPrefetch","Default","onNavigationIntent","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","Full","Intent","priority","existingPrefetchTask","getCurrentAppRouterState","appRouterState","treeAtTimeOfPrefetch","tree","nextUrl","cacheKey","pingVisibleLinks","task"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5049, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/cache.ts"],"sourcesContent":["import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type MapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport {\n  DOC_PREFETCH_RANGE_HEADER_VALUE,\n  doesExportedHtmlMatchBuildId,\n} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: null | MapEntry<RouteCacheEntry>\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: null | MapEntry<SegmentCacheEntry>\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it  i.e. the one\n  // optionally passed to router.prefetch(onInvalidate)  then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete  this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, we perform a range request of\n      // the first N bytes of the HTML document. The canonical URL is determined\n      // from the response.\n      //\n      // Then we can use the canonical URL to request the route tree.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const htmlResponse = await fetch(url, {\n        headers: {\n          Range: DOC_PREFETCH_RANGE_HEADER_VALUE,\n        },\n      })\n      const partialHtml = await htmlResponse.text()\n      if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {\n        // The target page is not part of this app, or it belongs to a\n        // different build.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n      urlAfterRedirects = htmlResponse.redirected\n        ? new URL(htmlResponse.url)\n        : url\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert  should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time  it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n"],"names":["HasLoadingBoundary","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","createFetch","createFromNextReadableStream","pingPrefetchTask","isPrefetchTaskDirty","startRevalidationCooldown","getRouteVaryPath","getFulfilledRouteVaryPath","getSegmentVaryPathForRequest","appendLayoutVaryPath","finalizeLayoutVaryPath","finalizePageVaryPath","clonePageVaryPathWithNewSearchParams","finalizeMetadataVaryPath","getAppBuildId","createHrefFromUrl","createCacheKey","createPrefetchRequestKey","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","createCacheMap","getFromCacheMap","setInCacheMap","setSizeInCacheMap","deleteFromCacheMap","isValueExpired","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentRequestKeyPart","HEAD_REQUEST_KEY","ROOT_SEGMENT_REQUEST_KEY","normalizeFlightData","prepareFlightRouterStateForRequest","STATIC_STALETIME_MS","pingVisibleLinks","PAGE_SEGMENT_KEY","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","FetchStrategy","createPromiseWithResolvers","getStaleTimeMs","staleTimeSeconds","Math","max","EntryStatus","isOutputExportMode","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","currentCacheVersion","getCurrentCacheVersion","revalidateEntireCache","nextUrl","tree","pingInvalidationListeners","attachInvalidationListener","task","onInvalidate","Set","add","notifyInvalidationListener","error","reportError","console","tasks","readRouteCacheEntry","now","key","varyPath","pathname","search","isRevalidation","readSegmentCacheEntry","readRevalidatingSegmentCacheEntry","waitForSegmentCacheEntry","pendingEntry","promiseWithResolvers","promise","readOrCreateRouteCacheEntry","existingEntry","canonicalUrl","status","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","renderedSearch","ref","size","staleAt","Infinity","version","requestOptimisticRouteCacheEntry","requestedUrl","requestedSearch","urlWithoutSearchParams","URL","routeWithNoSearchParams","href","canonicalUrlForRouteWithNoSearchParams","origin","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","location","optimisticCanonicalUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","slots","parallelRouteKey","childTree","isPage","requestKey","segment","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","readOrCreateSegmentCacheEntry","fetchStrategy","route","varyPathForRequest","createDetachedSegmentCacheEntry","readOrCreateRevalidatingSegmentEntry","overwriteRevalidatingSegmentCacheEntry","upsertSegmentEntry","candidateEntry","canNewFetchStrategyProvideMoreContent","isPartial","rejectedEntry","loading","rsc","emptyEntry","PPR","upgradeToPendingSegment","pingBlockedTasks","entry","fulfillRouteCacheEntry","metadataVaryPath","SubtreeHasNoLoadingBoundary","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","resolve","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","acc","pathnameParts","split","filter","p","index","rootSegment","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","childPrefetch","childParamName","name","childParamType","paramType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","childParamKey","childPathnamePartsIndex","childRequestKeyPart","childRequestKey","endsWith","SegmentHasLoadingBoundary","convertRootFlightRouterStateToRouteTree","flightRouterState","convertFlightRouterStateToRouteTree","parentPartialVaryPath","originalSegment","Array","isArray","paramCacheKey","parallelRoutes","childRouterState","undefined","convertRouteTreeToFlightRouterState","routeTree","fetchRouteOnCacheMiss","segmentPath","headers","url","response","urlAfterRedirects","htmlResponse","fetch","Range","partialHtml","text","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","get","includes","closed","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","buildId","staleTimeMs","staleTime","b","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","value","fetchSegmentOnCacheMiss","routeKey","normalizedRequestKey","requestUrl","fetchSegmentPrefetchesUsingDynamicRequest","dynamicRequestTree","spawnedEntries","has","Full","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","length","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","f","flightData","isRootRender","parseInt","isNaN","entries","values","push","flightDatas","seedData","i","writeSeedDataIntoCache","head","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","seedDataChildren","childSeedData","ownedEntry","possiblyNewEntry","newEntry","fetchPriority","shouldImmediatelyDecode","contentType","isFlightResponse","startsWith","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","slice","staticExportFilename","currentStrategy","newStrategy"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6375, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/navigation.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  listenForDynamicRequest,\n  type Task as PPRNavigationTask,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype NoOpNavigationResult = {\n  tag: NavigationResultTag.NoOp\n  data: {\n    canonicalUrl: string\n    shouldScroll: boolean\n  }\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath>\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<\n    MPANavigationResult | NoOpNavigationResult | SuccessfulNavigationResult\n  >\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | NoOpNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation =\n    // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      shouldScroll,\n      url.hash\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        shouldScroll,\n        url.hash\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      shouldScroll,\n      url.hash,\n      collectedDebugInfo\n    ),\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    const dynamicRequestTree = task.dynamicRequestTree\n    if (dynamicRequestTree !== null) {\n      const promiseForDynamicServerResponse = fetchServerResponse(\n        new URL(canonicalUrl, url.origin),\n        {\n          flightRouterState: dynamicRequestTree,\n          nextUrl,\n        }\n      )\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes  it's\n      // fully static. We can skip the dynamic request.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl,\n      shouldScroll,\n    },\n  }\n}\n\nfunction navigationTaskToResult(\n  task: PPRNavigationTask,\n  currentCacheNode: CacheNode,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath>,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  const flightRouterState = task.route\n  if (flightRouterState === null) {\n    // When no router state is provided, it signals that we should perform an\n    // MPA navigation.\n    return {\n      tag: NavigationResultTag.MPA,\n      data: canonicalUrl,\n    }\n  }\n  const newCacheNode = task.node\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState,\n      cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Since we don't know yet whether the segment is partial or fully\n        // static, we must assume it's partial; we can't skip the\n        // dynamic request.\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  shouldScroll: boolean,\n  hash: string,\n  collectedDebugInfo: Array<unknown>\n): Promise<\n  MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: currentFlightRouterState,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(\n    currentFlightRouterState,\n    flightData\n  )\n\n  // In our simulated prefetch payload, we pretend that there's no seed data\n  // nor a prefetch head.\n  const prefetchSeedData = null\n  const prefetchHead = null\n  const isPrefetchHeadPartial = true\n\n  // Now we proceed exactly as we would for normal navigation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    // In this case, we've already sent the dynamic request, so we don't\n    // actually use the request tree created by `startPPRNavigation`,\n    // except to check if it contains dynamic holes.\n    //\n    // This is almost always true, but it could be false if all the segment data\n    // was present in the cache, but the route tree was not. E.g. navigating\n    // to a URL that was not prefetched but rewrites to a different URL\n    // that was.\n    const hasDynamicHoles = task.dynamicRequestTree !== null\n    if (hasDynamicHoles) {\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes  it's\n      // fully static. We don't need to process the server response further.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      createHrefFromUrl(canonicalUrl),\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl: createHrefFromUrl(canonicalUrl),\n      shouldScroll,\n    },\n  }\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatch(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>\n): FlightRouterState {\n  // Takes the current FlightRouterState and applies the router state patch\n  // received from the server, to create a full FlightRouterState tree that we\n  // can pretend was returned by a prefetch.\n  //\n  // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n  // to handle stuff like interception routes or diffing since that will be\n  // handled later.)\n  let baseTree = currentTree\n  for (const { segmentPath, tree: treePatch } of flightData) {\n    // If the server sends us multiple tree patches, we only need to clone the\n    // base tree when applying the first patch. After the first patch, we can\n    // apply the remaining patches in place without copying.\n    const canMutateInPlace = baseTree !== currentTree\n    baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(\n      baseTree,\n      treePatch,\n      segmentPath,\n      canMutateInPlace,\n      0\n    )\n  }\n\n  return baseTree\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(\n  baseRouterState: FlightRouterState,\n  patch: FlightRouterState,\n  segmentPath: FlightSegmentPath,\n  canMutateInPlace: boolean,\n  index: number\n) {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return patch\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n  // the FlightRouterState patch in the same request as the dynamic data.\n  // Therefore we don't need to worry about diffing the segment values; we can\n  // assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseChildren = baseRouterState[1]\n  const newChildren: { [parallelRouteKey: string]: FlightRouterState } = {}\n  for (const parallelRouteKey in baseChildren) {\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const childBaseRouterState = baseChildren[parallelRouteKey]\n      newChildren[parallelRouteKey] =\n        simulatePrefetchTreeUsingDynamicTreePatchImpl(\n          childBaseRouterState,\n          patch,\n          segmentPath,\n          canMutateInPlace,\n          // Advance the index by two and keep cloning until we reach\n          // the end of the segment path.\n          index + 2\n        )\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newChildren[parallelRouteKey] = baseChildren[parallelRouteKey]\n    }\n  }\n\n  if (canMutateInPlace) {\n    // We can mutate the base tree in place, because the base tree is already\n    // a clone.\n    baseRouterState[1] = newChildren\n    return baseRouterState\n  }\n\n  // Clone all the fields except the children.\n  //\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n"],"names":["fetchServerResponse","startPPRNavigation","listenForDynamicRequest","createHrefFromUrl","EntryStatus","readRouteCacheEntry","readSegmentCacheEntry","waitForSegmentCacheEntry","requestOptimisticRouteCacheEntry","createCacheKey","addSearchParamsIfPageSegment","NavigationResultTag","navigate","url","currentUrl","currentCacheNode","currentFlightRouterState","nextUrl","shouldScroll","accumulation","now","Date","href","isSamePageNavigation","window","location","cacheKey","route","status","Fulfilled","snapshot","readRenderSnapshotFromCache","tree","prefetchFlightRouterState","flightRouterState","prefetchSeedData","seedData","headSnapshot","readHeadSnapshotFromCache","prefetchHead","rsc","isPrefetchHeadPartial","isPartial","newCanonicalUrl","canonicalUrl","hash","renderedSearch","navigateUsingPrefetchedRouteTree","Rejected","optimisticRoute","newRenderedSearch","collectedDebugInfo","undefined","tag","Async","data","navigateDynamicallyWithNoPrefetch","scrollableSegments","task","dynamicRequestTree","promiseForDynamicServerResponse","URL","origin","navigationTaskToResult","NoOp","MPA","newCacheNode","node","Success","cacheNode","childRouterStates","childSeedDatas","slots","parallelRouteKey","childTree","childResult","loading","segmentEntry","varyPath","Pending","promiseForFulfilledEntry","then","entry","Empty","segment","Object","fromEntries","URLSearchParams","hasRuntimePrefetch","isRootLayout","metadata","result","newUrl","flightData","debugInfo","debugInfoFromResponse","push","simulatePrefetchTreeUsingDynamicTreePatch","hasDynamicHoles","currentTree","baseTree","segmentPath","treePatch","canMutateInPlace","simulatePrefetchTreeUsingDynamicTreePatchImpl","baseRouterState","patch","index","length","updatedParallelRouteKey","baseChildren","newChildren","childBaseRouterState","clone"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6786, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n"],"names":["createHrefFromUrl","handleMutable","navigate","navigateUsingSegmentCache","NavigationResultTag","getStaleTimeMs","DYNAMIC_STALETIME_MS","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","handleNavigationResult","result","tag","MPA","newUrl","data","NoOp","newCanonicalUrl","oldUrl","URL","onlyHashChange","pathname","search","hash","shouldScroll","hashFragment","Success","cache","cacheNode","patchedTree","flightRouterState","renderedSearch","Async","then","asyncResult","navigateReducer","action","isExternalUrl","navigateType","href","preserveCustomHistoryState","toString","document","getElementById","currentUrl","location","origin","tree","nextUrl"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6928, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../shared/lib/app-router-types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\nexport function fillLazyItemsTillLeafWithHead(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined\n        ? cacheNodeSeedData[1][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[0]\n          const loading = parallelSeedData[2]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior  no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            navigatedAt,\n          }\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n            navigatedAt,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          navigatedAt,\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[0]\n      const loading = parallelSeedData[2]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head\n    )\n  }\n}\n"],"names":["createRouterCacheKey","fillLazyItemsTillLeafWithHead","navigatedAt","newCache","existingCache","routerState","cacheNodeSeedData","head","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","set","existingParallelRoutes"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7050, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/invalidate-cache-by-router-state.ts"],"sourcesContent":["import type {\n  CacheNode,\n  FlightRouterState,\n} from '../../../shared/lib/app-router-types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n"],"names":["createRouterCacheKey","invalidateCacheByRouterState","newCache","existingCache","routerState","key","segmentForParallelRoute","cacheKey","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","delete","set"],"mappings":";;;;AAIA,SAASA,oBAAoB,QAAQ,4BAA2B;;AAKzD,SAASC,6BACdC,QAAmB,EACnBC,aAAwB,EACxBC,WAA8B;IAE9B,uFAAuF;IACvF,IAAK,MAAMC,OAAOD,WAAW,CAAC,EAAE,CAAE;QAChC,MAAME,0BAA0BF,WAAW,CAAC,EAAE,CAACC,IAAI,CAAC,EAAE;QACtD,MAAME,eAAWP,0SAAAA,EAAqBM;QACtC,MAAME,kCACJL,cAAcM,cAAc,CAACC,GAAG,CAACL;QACnC,IAAIG,iCAAiC;YACnC,IAAIG,yBAAyB,IAAIC,IAAIJ;YACrCG,uBAAuBE,MAAM,CAACN;YAC9BL,SAASO,cAAc,CAACK,GAAG,CAACT,KAAKM;QACnC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 7073, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"sourcesContent":["import type { CacheNode, Segment } from '../../../shared/lib/app-router-types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const rsc = cacheNodeSeedData[0]\n        const loading = cacheNodeSeedData[2]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc: fillLazyItems || segment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n          navigatedAt,\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData\n): void {\n  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, true)\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData\n): void {\n  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, false)\n}\n"],"names":["invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","createRouterCacheKey","PAGE_SEGMENT_KEY","fillCacheHelper","navigatedAt","newCache","existingCache","flightData","fillLazyItems","segmentPath","seedData","cacheNodeSeedData","tree","treePatch","head","newCacheNode","existingCacheNode","i","length","parallelRouteKey","segment","isLastEntry","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","rsc","loading","prefetchRsc","prefetchHead","fillCacheWithNewSubTreeData","fillCacheWithNewSubTreeDataButOnlyLoading"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7167, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/apply-flight-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  navigatedAt: number,\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[0]\n    const loading = seedData[2]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior  no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(navigatedAt, cache, existingCache, flightData)\n  }\n\n  return true\n}\n"],"names":["fillLazyItemsTillLeafWithHead","fillCacheWithNewSubTreeData","applyFlightData","navigatedAt","existingCache","cache","flightData","tree","treePatch","seedData","head","isRootRender","rsc","loading","prefetchRsc","parallelRoutes","Map"],"mappings":";;;;AACA,SAASA,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,2BAA2B,QAAQ,qCAAoC;;;AAGzE,SAASC,gBACdC,WAAmB,EACnBC,aAAwB,EACxBC,KAAgB,EAChBC,UAAgC;IAEhC,0DAA0D;IAC1D,MAAM,EAAEC,MAAMC,SAAS,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE,GAAGL;IAE1D,8FAA8F;IAC9F,IAAIG,aAAa,MAAM;QACrB,OAAO;IACT;IAEA,IAAIE,cAAc;QAChB,MAAMC,MAAMH,QAAQ,CAAC,EAAE;QACvB,MAAMI,UAAUJ,QAAQ,CAAC,EAAE;QAC3BJ,MAAMQ,OAAO,GAAGA;QAChBR,MAAMO,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BP,MAAMS,WAAW,GAAG;YACpBd,wUAAAA,EACEG,aACAE,OACAD,eACAI,WACAC,UACAC;IAEJ,OAAO;QACL,2CAA2C;QAC3CL,MAAMO,GAAG,GAAGR,cAAcQ,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BP,MAAMS,WAAW,GAAGV,cAAcU,WAAW;QAC7CT,MAAMU,cAAc,GAAG,IAAIC,IAAIZ,cAAcW,cAAc;QAC3DV,MAAMQ,OAAO,GAAGT,cAAcS,OAAO;QACrC,4DAA4D;YAC5DZ,gUAAAA,EAA4BE,aAAaE,OAAOD,eAAeE;IACjE;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 7212, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  navigatedAt: number\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  navigatedAt,\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then((result) => {\n      if (typeof result !== 'string') {\n        const { flightData } = result\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(\n            navigatedAt,\n            updatedCache,\n            updatedCache,\n            flightDataPath\n          )\n        }\n      } else {\n        // When result is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      navigatedAt,\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n"],"names":["applyFlightData","fetchServerResponse","PAGE_SEGMENT_KEY","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","navigatedAt","state","updatedCache","includeNextUrl","canonicalUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","has","add","fetchPromise","URL","location","origin","flightRouterState","nextUrl","then","result","flightData","flightDataPath","push","key","parallelFetchPromise","Promise","all","addRefreshMarkerToActiveParallelSegments","tree","path","segment","includes"],"mappings":";;;;;;AAKA,SAASA,eAAe,QAAQ,sBAAqB;AACrD,SAASC,mBAAmB,QAAQ,0BAAyB;AAC7D,SAASC,gBAAgB,QAAQ,8BAA6B;;;;AAsBvD,eAAeC,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,EACjDG,WAAW,EACXC,KAAK,EACLF,WAAW,EACXG,YAAY,EACZC,cAAc,EACdR,eAAe,EACfG,WAAWC,WAAW,EACtBK,YAAY,EAIb;IACC,MAAM,GAAGC,gBAAgBC,aAAaC,cAAc,GAAGR;IACvD,MAAMS,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACZ,gBAAgBc,GAAG,CAACH,cACrB;QACAX,gBAAgBe,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,mBAAepB,oSAAAA,EACnB,IAAIqB,IAAIN,aAAaO,SAASC,MAAM,GACpC;YACE,gGAAgG;YAChG,8HAA8H;YAC9HC,mBAAmB;gBAACjB,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAE;aAAU;YACrEkB,SAASb,iBAAiBF,MAAMe,OAAO,GAAG;QAC5C,GACAC,IAAI,CAAC,CAACC;YACN,IAAI,OAAOA,WAAW,UAAU;gBAC9B,MAAM,EAAEC,UAAU,EAAE,GAAGD;gBACvB,KAAK,MAAME,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;wBAC5E7B,4RAAAA,EACEU,aACAE,cACAA,cACAkB;gBAEJ;YACF,OAAO;YACL,wGAAwG;YACxG,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAZ,cAAca,IAAI,CAACV;IACrB;IAEA,IAAK,MAAMW,OAAOjB,eAAgB;QAChC,MAAMkB,uBAAuB1B,oCAAoC;YAC/DG;YACAC;YACAF,aAAaM,cAAc,CAACiB,IAAI;YAChCpB;YACAC;YACAR;YACAG;YACAM;QACF;QAEAI,cAAca,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAACjB;AACpB;AAQO,SAASkB,yCACdC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASxB,kBAAkBE,cAAc,GAAGoB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACtC,iPAAAA,KAAqBe,kBAAkB,WAAW;QACrEoB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAML,OAAOjB,eAAgB;QAChCqB,yCAAyCrB,cAAc,CAACiB,IAAI,EAAEM;IAChE;AACF","ignoreList":[0]}},
    {"offset": {"line": 7299, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n"],"names":["DEFAULT_SEGMENT_KEY","getNextFlightSegmentPath","matchSegment","addRefreshMarkerToActiveParallelSegments","applyPatch","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","applyRouterStatePatchToTree","flightSegmentPath","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch"],"mappings":";;;;AAIA,SAASA,mBAAmB,QAAQ,8BAA6B;AACjE,SAASC,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,wCAAwC,QAAQ,uCAAsC;;;;;AAE/F;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B;IAE5B,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGH;IAChD,MAAM,CAACI,cAAcC,oBAAoB,GAAGJ;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEG,iBAAiBT,oPAAAA,IACjBO,mBAAmBP,oPAAAA,EACnB;QACA,OAAOK;IACT;IAEA,QAAIH,8PAAAA,EAAaK,gBAAgBE,eAAe;QAC9C,MAAME,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAOJ,sBAAuB;YACvC,MAAMK,8BACJ,OAAOH,mBAAmB,CAACE,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGR,WACvBI,qBAAqB,CAACI,IAAI,EAC1BF,mBAAmB,CAACE,IAAI;YAE5B,OAAO;gBACLD,iBAAiB,CAACC,IAAI,GAAGJ,qBAAqB,CAACI,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOF,oBAAqB;YACrC,IAAIC,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGF,mBAAmB,CAACE,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACP;YAAgBI;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIN,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOS;IACT;IAEA,OAAOR;AACT;AAOO,SAASS,4BACdC,iBAAoC,EACpCC,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAID,kBAAkBS,MAAM,KAAK,GAAG;QAClC,MAAMX,OAA0BV,WAAWa,mBAAmBC;YAE9Df,yUAAAA,EAAyCW,MAAMK;QAE/C,OAAOL;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGX;IAE3C,iGAAiG;IACjG,IAAI,KAACd,8PAAAA,EAAawB,gBAAgBN,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMQ,cAAcZ,kBAAkBS,MAAM,KAAK;IAEjD,IAAII;IACJ,IAAID,aAAa;QACfC,qBAAqBzB,WAAWiB,cAAc,CAACM,iBAAiB,EAAET;IACpE,OAAO;QACLW,qBAAqBd,gCACnBd,oQAAAA,EAAyBe,oBACzBK,cAAc,CAACM,iBAAiB,EAChCT,WACAC;QAGF,IAAIU,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BE,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGK,cAAc;YACjB,CAACM,iBAAiB,EAAEE;QACtB;QACAP;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBV,IAAI,CAAC,EAAE,GAAG;IACZ;QAEAX,yUAAAA,EAAyCW,MAAMK;IAE/C,OAAOL;AACT","ignoreList":[0]}},
    {"offset": {"line": 7398, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const { serverResponse, navigatedAt } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof serverResponse === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      serverResponse,\n      state.pushRef.pendingPush\n    )\n  }\n\n  const { flightData, canonicalUrl, renderedSearch } = serverResponse\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.renderedSearch = renderedSearch\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n"],"names":["createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","applyFlightData","handleMutable","createEmptyCacheNode","serverPatchReducer","state","action","serverResponse","navigatedAt","mutable","preserveCustomHistoryState","pushRef","pendingPush","flightData","canonicalUrl","renderedSearch","currentTree","tree","currentCache","cache","normalizedFlightData","segmentPath","flightSegmentPath","treePatch","newTree","patchedTree"],"mappings":";;;;AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AAEjD,SAASC,oBAAoB,QAAQ,mBAAkB;;;;;;;;AAEhD,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,cAAc,EAAEC,WAAW,EAAE,GAAGF;IAExC,MAAMG,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOH,mBAAmB,UAAU;QACtC,WAAOP,sSAAAA,EACLK,OACAI,SACAF,gBACAF,MAAMM,OAAO,CAACC,WAAW;IAE7B;IAEA,MAAM,EAAEC,UAAU,EAAEC,YAAY,EAAEC,cAAc,EAAE,GAAGR;IAErD,IAAIS,cAAcX,MAAMY,IAAI;IAC5B,IAAIC,eAAeb,MAAMc,KAAK;IAE9B,KAAK,MAAMC,wBAAwBP,WAAY;QAC7C,MAAM,EAAEQ,aAAaC,iBAAiB,EAAEL,MAAMM,SAAS,EAAE,GACvDH;QAEF,MAAMI,cAAU1B,gUAAAA,CACd,CACA,qBADsB;YACrB;eAAOwB;SAAkB,EAC1BN,aACAO,WACAlB,MAAMS,YAAY;QAGpB,kIAAkI;QAClI,8GAA8G;QAC9G,oIAAoI;QACpI,mIAAmI;QACnI,6BAA6B;QAC7B,IAAIU,YAAY,MAAM;YACpB,OAAOnB;QACT;QAEA,QAAIN,gUAAAA,EAA4BiB,aAAaQ,UAAU;YACrD,WAAOxB,sSAAAA,EACLK,OACAI,SACAJ,MAAMS,YAAY,EAClBT,MAAMM,OAAO,CAACC,WAAW;QAE7B;QAEAH,QAAQK,YAAY,OAAGjB,oSAAAA,EAAkBiB;QAEzC,MAAMK,YAAmBhB,kQAAAA;YACzBF,4RAAAA,EAAgBO,aAAaU,cAAcC,OAAOC;QAElDX,QAAQgB,WAAW,GAAGD;QACtBf,QAAQM,cAAc,GAAGA;QACzBN,QAAQU,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,WAAOtB,oRAAAA,EAAcG,OAAOI;AAC9B","ignoreList":[0]}},
    {"offset": {"line": 7459, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, historyState } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n"],"names":["createHrefFromUrl","extractPathFromFlightRouterState","updateCacheNodeOnPopstateRestoration","restoreReducer","state","action","url","historyState","href","treeToRestore","renderedSearch","tree","oldCache","cache","newCache","process","env","__NEXT_PPR","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","nextUrl","pathname","previousNextUrl","debugInfo"],"mappings":";;;;AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SAASC,gCAAgC,QAAQ,0BAAyB;AAC1E,SAASC,oCAAoC,QAAQ,qBAAoB;;;;AAGlE,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,YAAY,EAAE,GAAGF;IAC9B,MAAMG,WAAOR,oSAAAA,EAAkBM;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAIG;IACJ,IAAIC;IACJ,IAAIH,cAAc;QAChBE,gBAAgBF,aAAaI,IAAI;QACjCD,iBAAiBH,aAAaG,cAAc;IAC9C,OAAO;QACLD,gBAAgBL,MAAMO,IAAI;QAC1BD,iBAAiBN,MAAMM,cAAc;IACvC;IAEA,MAAME,WAAWR,MAAMS,KAAK;IAC5B,MAAMC,WAAWC,QAAQC,GAAG,CAACC,UAAU,GAEnC,aACA,wDADqE,GACV;IAC3D,2BAA2B;IAC3Bf,0BACAU,WADqCA,UAAUH;IAGnD,OAAO;QACL,oBAAoB;QACpBS,cAAcV;QACdE;QACAS,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBnB,MAAMmB,iBAAiB;QAC1CV,OAAOC;QACP,wBAAwB;QACxBH,MAAMF;QACNe,aAASvB,gTAAAA,EAAiCQ,kBAAkBH,IAAImB,QAAQ;QACxEC,iBAAiB;QACjBC,WAAW;IACb;AACF","ignoreList":[0]}},
    {"offset": {"line": 7514, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/handle-segment-mismatch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n"],"names":["handleExternalUrl","handleSegmentMismatch","state","action","treePatch","process","env","NODE_ENV","console","warn","type","JSON","stringify","tree","canonicalUrl"],"mappings":";;;;AACA,SAASA,iBAAiB,QAAQ,8BAA6B;;AAUxD,SAASC,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,IAAIC,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAe;QAC1CC,QAAQC,IAAI,CACV,sJACE,+BACA,CAAC,aAAa,EAAEN,OAAOO,IAAI,CAAC,IAAI,CAAC,GACjC,CAAC,cAAc,EAAEC,KAAKC,SAAS,CAACV,MAAMW,IAAI,EAAE,IAAI,CAAC,GACjD,CAAC,oBAAoB,EAAEF,KAAKC,SAAS,CAACR,YAAY;IAExD;IAEA,WAAOJ,sSAAAA,EAAkBE,OAAO,CAAC,GAAGA,MAAMY,YAAY,EAAE;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 7530, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["isInterceptionRouteAppPath","hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","key"],"mappings":";;;;AACA,SAASA,0BAA0B,QAAQ,0DAAyD;;AAE7F,SAASC,kCAAkC,CAChDC,SACAC,eACkB;IAClB,wGAAwG;IACxG,IACEC,MAAMC,OAAO,CAACH,YACbA,CAAAA,OAAO,CAAC,EAAE,KAAK,gBACdA,OAAO,CAAC,EAAE,KAAK,gBACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,aACfA,OAAO,CAAC,EAAE,KAAK,SAAQ,GACzB;QACA,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,gBAAYF,6RAAAA,EAA2BE,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMG,OAAOH,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACG,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 7559, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  const navigatedAt = Date.now()\n  return cache.lazyData.then(\n    async (result: FetchServerResponseResult) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof result === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          result,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const { flightData, canonicalUrl, renderedSearch } = result\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const loading = cacheNodeSeedData[2]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          revalidateEntireCache(state.nextUrl, newTree)\n        }\n\n        await refreshInactiveParallelSegments({\n          navigatedAt,\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n        mutable.renderedSearch = renderedSearch\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","refreshInactiveParallelSegments","revalidateEntireCache","refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","includeNextUrl","lazyData","URL","flightRouterState","nextUrl","navigatedAt","Date","now","then","result","pushRef","pendingPush","flightData","renderedSearch","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","rsc","loading","prefetchRsc","undefined","updatedTree","updatedCache","patchedTree"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7664, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts"],"sourcesContent":["import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  const navigatedAt = Date.now()\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    (result: FetchServerResponseResult) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof result === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          result,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const { flightData, canonicalUrl, renderedSearch } = result\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const applied = applyFlightData(\n          navigatedAt,\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.renderedSearch = renderedSearch\n        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","applyFlightData","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","hmrRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","includeNextUrl","tree","navigatedAt","Date","now","lazyData","URL","flightRouterState","nextUrl","isHmrRefresh","then","result","pushRef","pendingPush","flightData","renderedSearch","currentTree","currentCache","normalizedFlightData","treePatch","isRootRender","console","log","newTree","applied","patchedTree","hmrRefreshReducerNoop","_action","hmrRefreshReducer","process","env","NODE_ENV"],"mappings":";;;;AAAA,SACEA,mBAAmB,QAEd,2BAA0B;AACjC,SAASC,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AACjD,SAASC,eAAe,QAAQ,uBAAsB;AAEtD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,qBAAqB,QAAQ,6BAA4B;AAClE,SAASC,iCAAiC,QAAQ,2CAA0C;;;;;;;;;;;AAE5F,wFAAwF;AACxF,SAASC,sBACPC,KAA2B,EAC3BC,MAAwB;IAExB,MAAM,EAAEC,MAAM,EAAE,GAAGD;IACnB,MAAME,UAAmB,CAAC;IAC1B,MAAMC,OAAOJ,MAAMK,YAAY;IAE/BF,QAAQG,0BAA0B,GAAG;IAErC,MAAMC,YAAmBX,kQAAAA;IACzB,sFAAsF;IACtF,sHAAsH;IACtH,MAAMY,qBAAiBV,wVAAAA,EAAkCE,MAAMS,IAAI;IAEnE,uDAAuD;IACvD,wCAAwC;IACxC,MAAMC,cAAcC,KAAKC,GAAG;IAC5BL,MAAMM,QAAQ,OAAGxB,oSAAAA,EAAoB,IAAIyB,IAAIV,MAAMF,SAAS;QAC1Da,mBAAmB;YAACf,MAAMS,IAAI,CAAC,EAAE;YAAET,MAAMS,IAAI,CAAC,EAAE;YAAET,MAAMS,IAAI,CAAC,EAAE;YAAE;SAAU;QAC3EO,SAASR,iBAAiBR,MAAMgB,OAAO,GAAG;QAC1CC,cAAc;IAChB;IAEA,OAAOV,MAAMM,QAAQ,CAACK,IAAI,CACxB,CAACC;QACC,4DAA4D;QAC5D,IAAI,OAAOA,WAAW,UAAU;YAC9B,WAAO1B,sSAAAA,EACLO,OACAG,SACAgB,QACAnB,MAAMoB,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAM,EAAEC,UAAU,EAAEjB,YAAY,EAAEkB,cAAc,EAAE,GAAGJ;QAErD,+DAA+D;QAC/DZ,MAAMM,QAAQ,GAAG;QAEjB,IAAIW,cAAcxB,MAAMS,IAAI;QAC5B,IAAIgB,eAAezB,MAAMO,KAAK;QAE9B,KAAK,MAAMmB,wBAAwBJ,WAAY;YAC7C,MAAM,EAAEb,MAAMkB,SAAS,EAAEC,YAAY,EAAE,GAAGF;YAC1C,IAAI,CAACE,cAAc;gBACjB,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZ,OAAO9B;YACT;YAEA,MAAM+B,cAAUxC,gUAAAA,CACd,CACA,qBADsB;gBACrB;aAAG,EACJiC,aACAG,WACA3B,MAAMK,YAAY;YAGpB,IAAI0B,YAAY,MAAM;gBACpB,WAAOlC,wSAAAA,EAAsBG,OAAOC,QAAQ0B;YAC9C;YAEA,QAAInC,gUAAAA,EAA4BgC,aAAaO,UAAU;gBACrD,WAAOtC,sSAAAA,EACLO,OACAG,SACAC,MACAJ,MAAMoB,OAAO,CAACC,WAAW;YAE7B;YAEA,MAAMW,cAAUrC,4RAAAA,EACde,aACAe,cACAlB,OACAmB;YAGF,IAAIM,SAAS;gBACX7B,QAAQI,KAAK,GAAGA;gBAChBkB,eAAelB;YACjB;YAEAJ,QAAQ8B,WAAW,GAAGF;YACtB5B,QAAQoB,cAAc,GAAGA;YACzBpB,QAAQE,YAAY,OAAGf,oSAAAA,EAAkBe;YAEzCmB,cAAcO;QAChB;QACA,WAAOrC,oRAAAA,EAAcM,OAAOG;IAC9B,GACA,IAAMH;AAEV;AAEA,SAASkC,sBACPlC,KAA2B,EAC3BmC,OAAyB;IAEzB,OAAOnC;AACT;AAEO,MAAMoC,oBACXC,QAAQC,GAAG,CAACC,QAAQ,KAAK,aACrBL,0BACAnC,sBAAqB","ignoreList":[0]}},
    {"offset": {"line": 7758, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/normalize-trailing-slash.ts"],"sourcesContent":["import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n"],"names":["removeTrailingSlash","parsePath","normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","__NEXT_TRAILING_SLASH","test","endsWith"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ,mDAAkD;AACtF,SAASC,SAAS,QAAQ,wCAAuC;;;AAM1D,MAAMC,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,QAAQC,QAAQC,GAAG,CAACC,4BAA4B,EAAE;QACrE,OAAOJ;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,OAAGT,mQAAAA,EAAUE;IAC5C,IAAIE,QAAQC,GAAG,CAACK,qBAAqB,EAAE;;IAUvC,OAAO,OAAGX,2RAAAA,EAAoBQ,YAAYC,QAAQC,MAAM;AAC1D,EAAC","ignoreList":[0]}},
    {"offset": {"line": 7779, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/add-base-path.ts"],"sourcesContent":["import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n"],"names":["addPathPrefix","normalizePathTrailingSlash","basePath","process","env","__NEXT_ROUTER_BASEPATH","addBasePath","path","required","__NEXT_MANUAL_CLIENT_BASE_PATH"],"mappings":";;;;AAAA,SAASA,aAAa,QAAQ,6CAA4C;AAC1E,SAASC,0BAA0B,QAAQ,6BAA4B;;;AAEvE,MAAMC,WAAYC,QAAQC,GAAG,CAACC,sBAAsB,MAAe;AAE5D,SAASC,YAAYC,IAAY,EAAEC,QAAkB;IAC1D,WAAOP,2QAAAA,EACLE,QAAQC,GAAG,CAACK,0BACRF,IADsC,IAAI,CAACC,qBAE3CR,+QAAAA,EAAcO,MAAML;AAE5B","ignoreList":[0]}},
    {"offset": {"line": 7795, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/assign-location.ts"],"sourcesContent":["import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n"],"names":["addBasePath","assignLocation","location","url","startsWith","urlBase","origin","pathname","URL","endsWith","href"],"mappings":";;;;AAAA,SAASA,WAAW,QAAQ,kBAAiB;;AAStC,SAASC,eAAeC,QAAgB,EAAEC,GAAQ;IACvD,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,UAAUF,IAAIG,MAAM,GAAGH,IAAII,QAAQ;QACzC,OAAO,IAAIC,IAIT,AAHA,AACA,6FAA6F,kBADkB;QAE/G,qGAAqG;QACpGH,CAAAA,QAAQI,QAAQ,CAAC,OAAOJ,UAAUA,UAAU,GAAE,IAAKH;IAExD;IAEA,OAAO,IAAIM,QAAIR,iPAAAA,EAAYE,WAAWC,IAAIO,IAAI;AAChD","ignoreList":[0]}},
    {"offset": {"line": 7814, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      // Store whether this action triggered any revalidation\n      // The action queue will use this information to potentially\n      // trigger a refresh action if the action was discarded\n      // (ie, due to a navigation, before the action completed)\n      if (actionRevalidated) {\n        action.didRevalidate = true\n      }\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[2]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          mutable.cache = cache\n          revalidateEntireCache(state.nextUrl, newTree)\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const redirectError = getRedirectError(\n          hasBasePath(redirectHref)\n            ? removeBasePath(redirectHref)\n            : redirectHref,\n          redirectType || RedirectType.push\n        )\n        // We mark the error as handled because we don't want the redirect to be tried later by\n        // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n        // again, as it's run within an effect.\n        // We don't actually need the RedirectBoundary to do a router.push because we already\n        // have all the necessary RSC data to render the new page within a single roundtrip.\n        ;(redirectError as any).handled = true\n        reject(redirectError)\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n"],"names":["callServer","findSourceMapURL","ACTION_HEADER","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_CONTENT_TYPE_HEADER","NEXT_REQUEST_ID_HEADER","UnrecognizedActionError","createFromFetch","createFromFetchBrowser","createTemporaryReferenceSet","encodeReply","assignLocation","createHrefFromUrl","handleExternalUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","hasInterceptionRouteInCurrentTree","handleSegmentMismatch","refreshInactiveParallelSegments","normalizeFlightData","prepareFlightRouterStateForRequest","getRedirectError","RedirectType","removeBasePath","hasBasePath","extractInfoFromServerReferenceId","omitUnusedArgs","revalidateEntireCache","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","info","usedArgs","type","body","headers","Accept","tree","NEXT_DEPLOYMENT_ID","self","__next_r","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","redirectHeader","location","_redirectType","split","redirectType","push","replace","undefined","isPrerender","revalidatedParts","revalidatedHeader","JSON","parse","paths","tag","cookie","e","NO_REVALIDATED_PARTS","redirectLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","response","Promise","resolve","debugChannel","a","f","serverActionReducer","action","reject","mutable","currentTree","preserveCustomHistoryState","previousNextUrl","navigatedAt","Date","now","then","flightData","redirectHref","pushRef","pendingPush","actionRevalidated","length","didRevalidate","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","rsc","cache","prefetchRsc","loading","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","redirectError","handled"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8103, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_RESTORE","ACTION_REFRESH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","navigateReducer","serverPatchReducer","restoreReducer","refreshReducer","hmrRefreshReducer","serverActionReducer","clientReducer","state","action","type","Error","serverReducer","_action","reducer","window"],"mappings":";;;;AAAA,SACEA,eAAe,EACfC,mBAAmB,EACnBC,cAAc,EACdC,cAAc,EACdC,kBAAkB,EAClBC,oBAAoB,QACf,yBAAwB;AAM/B,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,iBAAiB,QAAQ,iCAAgC;AAClE,SAASC,mBAAmB,QAAQ,mCAAkC;;;;;;;;AAEtE;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKf,+RAAAA;YAAiB;gBACpB,WAAOM,oSAAAA,EAAgBO,OAAOC;YAChC;QACA,KAAKb,mSAAAA;YAAqB;gBACxB,WAAOM,8SAAAA,EAAmBM,OAAOC;YACnC;QACA,KAAKZ,8RAAAA;YAAgB;gBACnB,WAAOM,kSAAAA,EAAeK,OAAOC;YAC/B;QACA,KAAKX,8RAAAA;YAAgB;gBACnB,WAAOM,kSAAAA,EAAeI,OAAOC;YAC/B;QACA,KAAKV,kSAAAA;YAAoB;gBACvB,WAAOM,4SAAAA,EAAkBG,OAAOC;YAClC;QACA,KAAKT,oSAAAA;YAAsB;gBACzB,WAAOM,gTAAAA,EAAoBE,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,OAAA,cAA2B,CAA3B,IAAIE,MAAM,mBAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0B;IACpC;AACF;AAEA,SAASC,cACPJ,KAA2B,EAC3BK,OAAuB;IAEvB,OAAOL;AACT;AAGO,MAAMM,UACX,OAAOC,WAAW,qBAAcH,gBAAgBL,cAAa","ignoreList":[0]}},
    {"offset": {"line": 8166, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/app-router-utils.ts"],"sourcesContent":["import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n"],"names":["isBot","addBasePath","isExternalURL","url","origin","window","location","createPrefetchURL","href","navigator","userAgent","URL","_","Error","process","env","NODE_ENV"],"mappings":";;;;;;AAAA,SAASA,KAAK,QAAQ,uCAAsC;AAC5D,SAASC,WAAW,QAAQ,mBAAkB;;;AAEvC,SAASC,cAAcC,GAAQ;IACpC,OAAOA,IAAIC,MAAM,KAAKC,OAAOC,QAAQ,CAACF,MAAM;AAC9C;AASO,SAASG,kBAAkBC,IAAY;IAC5C,kDAAkD;IAClD,QAAIR,2QAAAA,EAAMK,OAAOI,SAAS,CAACC,SAAS,GAAG;QACrC,OAAO;IACT;IAEA,IAAIP;IACJ,IAAI;QACFA,MAAM,IAAIQ,QAAIV,iPAAAA,EAAYO,OAAOH,OAAOC,QAAQ,CAACE,IAAI;IACvD,EAAE,OAAOI,GAAG;QACV,2EAA2E;QAC3E,kDAAkD;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,iBAAiB,EAAEL,KAAK,0CAA0C,CAAC,GADhE,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,uEAAuE;IACvE,IAAIM,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAe;QAC1C,OAAO;IACT;;;AAQF","ignoreList":[0]}},
    {"offset": {"line": 8207, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/segment-cache/prefetch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport { PrefetchPriority, type PrefetchTaskFetchStrategy } from './types'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription  it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n"],"names":["createPrefetchURL","createCacheKey","schedulePrefetchTask","PrefetchPriority","prefetch","href","nextUrl","treeAtTimeOfPrefetch","fetchStrategy","onInvalidate","url","cacheKey","Default"],"mappings":";;;;AACA,SAASA,iBAAiB,QAAQ,sBAAqB;AACvD,SAASC,cAAc,QAAQ,cAAa;AAC5C,SAASC,oBAAoB,QAAQ,cAAa;AAClD,SAASC,gBAAgB,QAAwC,UAAS;;;;;AAsBnE,SAASC,SACdC,IAAY,EACZC,OAAsB,EACtBC,oBAAuC,EACvCC,aAAwC,EACxCC,YAAiC;IAEjC,MAAMC,UAAMV,wQAAAA,EAAkBK;IAC9B,IAAIK,QAAQ,MAAM;QAChB,sCAAsC;QACtC;IACF;IACA,MAAMC,eAAWV,+QAAAA,EAAeS,IAAIL,IAAI,EAAEC;QAC1CJ,kRAAAA,EACES,UACAJ,sBACAC,eACAL,0QAAAA,CAAiBS,OAAO,EACxBH;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 8232, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/app-router-instance.ts"],"sourcesContent":["import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch(\n        {\n          type: ACTION_REFRESH,\n          origin: window.location.origin,\n        },\n        setState\n      )\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        case PrefetchKind.TEMPORARY: {\n          // This concept doesn't exist in the segment cache implementation.\n          return\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n        origin: window.location.origin,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n          origin: window.location.origin,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["ACTION_REFRESH","ACTION_SERVER_ACTION","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_HMR_REFRESH","PrefetchKind","reducer","startTransition","isThenable","FetchStrategy","prefetch","prefetchWithSegmentCache","dispatchAppRouterAction","addBasePath","isExternalURL","setLinkForCurrentNavigation","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","origin","window","location","prevState","state","payload","actionResult","handleResult","nextState","discarded","didRevalidate","resolve","then","err","reject","dispatchAction","resolvers","deferredPromise","Promise","newAction","last","globalActionQueue","createMutableActionQueue","initialState","instrumentationHooks","result","onRouterTransitionStart","Error","getCurrentAppRouterState","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","dispatchNavigateAction","href","navigateType","shouldScroll","linkInstanceRef","url","URL","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","isExternalUrl","locationSearch","search","dispatchTraverseAction","historyState","publicAppRouterInstance","back","history","forward","options","prefetchKind","kind","AUTO","fetchStrategy","PPR","FULL","Full","TEMPORARY","nextUrl","tree","onInvalidate","replace","scroll","push","refresh","hmrRefresh","NODE_ENV","router"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8526, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/errors/graceful-degrade-boundary.tsx"],"sourcesContent":["'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n"],"names":["Component","createRef","getDomNodeAttributes","node","result","i","attributes","length","attr","name","value","GracefulDegradeBoundary","constructor","props","state","hasError","rootHtml","htmlAttributes","htmlRef","getDerivedStateFromError","_","componentDidMount","htmlNode","current","Object","entries","forEach","key","setAttribute","render","window","document","documentElement","innerHTML","html","ref","suppressHydrationWarning","dangerouslySetInnerHTML","__html","children"],"mappings":";;;;;;;AAEA,SAASA,SAAS,EAAEC,SAAS,QAAwB,QAAO;AAF5D;;;AAYA,SAASC,qBAAqBC,IAAiB;IAC7C,MAAMC,SAAiC,CAAC;IACxC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,KAAKG,UAAU,CAACC,MAAM,EAAEF,IAAK;QAC/C,MAAMG,OAAOL,KAAKG,UAAU,CAACD,EAAE;QAC/BD,MAAM,CAACI,KAAKC,IAAI,CAAC,GAAGD,KAAKE,KAAK;IAChC;IACA,OAAON;AACT;AAEO,MAAMO,gCAAgCX,qOAAAA;IAQ3CY,YAAYC,KAAyB,CAAE;QACrC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEC,UAAU;QAAM;QAC/B,IAAI,CAACC,QAAQ,GAAG;QAChB,IAAI,CAACC,cAAc,GAAG,CAAC;QACvB,IAAI,CAACC,OAAO,GAAA,WAAA,OAAGjB,qOAAAA;IACjB;IAEA,OAAOkB,yBAAyBC,CAAU,EAAsB;QAC9D,OAAO;YAAEL,UAAU;QAAK;IAC1B;IAEAM,oBAAoB;QAClB,MAAMC,WAAW,IAAI,CAACJ,OAAO,CAACK,OAAO;QACrC,IAAI,IAAI,CAACT,KAAK,CAACC,QAAQ,IAAIO,UAAU;YACnC,yDAAyD;YACzDE,OAAOC,OAAO,CAAC,IAAI,CAACR,cAAc,EAAES,OAAO,CAAC,CAAC,CAACC,KAAKjB,MAAM;gBACvDY,SAASM,YAAY,CAACD,KAAKjB;YAC7B;QACF;IACF;IAEAmB,SAAS;QACP,MAAM,EAAEd,QAAQ,EAAE,GAAG,IAAI,CAACD,KAAK;QAC/B,kDAAkD;QAClD,IAAI,OAAOgB,2CAAW,eAAe,CAAC,IAAI,CAACd,QAAQ,EAAE;;QAKrD,IAAID,UAAU;YACZ,oDAAoD;YACpD,OAAA,WAAA,OACE,wOAAA,EAACmB,QAAAA;gBACCC,KAAK,IAAI,CAACjB,OAAO;gBACjBkB,wBAAwB,EAAA;gBACxBC,yBAAyB;oBACvBC,QAAQ,IAAI,CAACtB,QAAQ;gBACvB;;QAGN;QAEA,OAAO,IAAI,CAACH,KAAK,CAAC0B,QAAQ;IAC5B;AACF;uCAEe5B,wBAAuB","ignoreList":[0]}},
    {"offset": {"line": 8593, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/navigation-untracked.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n"],"names":["useContext","PathnameContext","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useUntrackedPathname"],"mappings":";;;;AAAA,SAASA,UAAU,QAAQ,QAAO;AAClC,SAASC,eAAe,QAAQ,uDAAsD;;;AAEtF;;;;;;CAMC,GACD,SAASC;IACP,IAAI,OAAOC,WAAW,kBAAa;QACjC,iEAAiE;QACjE,MAAM,EAAEC,oBAAoB,EAAE,GAC5BC,QAAQ;QAEV,MAAMC,gBAAgBF,qBAAqBG,QAAQ;QACnD,IAAI,CAACD,eAAe,OAAO;QAE3B,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAMC,iBAAiBH,cAAcI,mBAAmB;gBACxD,OAAOD,iBAAiBA,eAAeE,IAAI,GAAG,IAAI;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEL;QACJ;QAEA,OAAO;IACT;;;AAGF;AAaO,SAASM;IACd,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAIV,0BAA0B;QAC5B,OAAO;IACT;IAEA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,WAAOF,sOAAAA,EAAWC,iRAAAA;AACpB","ignoreList":[0]}},
    {"offset": {"line": 8651, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/handle-isr-error.tsx"],"sourcesContent":["const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isStaticGeneration) {\n      if (error) {\n        console.error(error)\n      }\n      throw error\n    }\n  }\n\n  return null\n}\n"],"names":["workAsyncStorage","window","require","undefined","HandleISRError","error","store","getStore","isStaticGeneration","console"],"mappings":";;;;AAAA,MAAMA,mBACJ,OAAOC,WAAW,qBAEZC,QAAQ,4KACRF,gBAAgB,GAClBG;AAKC,SAASC,eAAe,EAAEC,KAAK,EAAkB;IACtD,IAAIL,kBAAkB;QACpB,MAAMM,QAAQN,iBAAiBO,QAAQ;QACvC,IAAID,OAAOE,oBAAoB;YAC7B,IAAIH,OAAO;gBACTI,QAAQJ,KAAK,CAACA;YAChB;YACA,MAAMA;QACR;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 8672, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["React","useUntrackedPathname","isNextRouterError","handleHardNavError","HandleISRError","isBot","isBotUserAgent","window","navigator","userAgent","ErrorBoundaryHandler","Component","constructor","props","reset","setState","error","state","previousPathname","pathname","getDerivedStateFromError","getDerivedStateFromProps","process","env","__NEXT_APP_NAV_FAIL_HANDLING","render","errorStyles","errorScripts","this","errorComponent","children","ErrorBoundary"],"mappings":";;;;;;;AAEA,OAAOA,WAAyB,QAAO;AACvC,SAASC,oBAAoB,QAAQ,yBAAwB;AAC7D,SAASC,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,kBAAkB,QAAQ,wBAAuB;AAC1D,SAASC,cAAc,QAAQ,qBAAoB;AACnD,SAASC,KAAK,QAAQ,uCAAsC;AAP5D;;;;;;;;AASA,MAAMC,iBACJ,OAAOC,2CAAW,mBAAeF,2QAAAA,EAAME,OAAOC,SAAS,CAACC,SAAS;AA0B5D,MAAMC,6BAA6BV,mOAAAA,CAAMW,SAAS;IAIvDC,YAAYC,KAAgC,CAAE;QAC5C,KAAK,CAACA,QAAAA,IAAAA,CAoDRC,KAAAA,GAAQ;YACN,IAAI,CAACC,QAAQ,CAAC;gBAAEC,OAAO;YAAK;QAC9B;QArDE,IAAI,CAACC,KAAK,GAAG;YAAED,OAAO;YAAME,kBAAkB,IAAI,CAACL,KAAK,CAACM,QAAQ;QAAC;IACpE;IAEA,OAAOC,yBAAyBJ,KAAY,EAAE;QAC5C,QAAId,+QAAAA,EAAkBc,QAAQ;YAC5B,+DAA+D;YAC/D,4GAA4G;YAC5G,MAAMA;QACR;QAEA,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAOK,yBACLR,KAAgC,EAChCI,KAAgC,EACE;QAClC,MAAM,EAAED,KAAK,EAAE,GAAGC;QAElB,iCAAiC;QACjC,8CAA8C;QAC9C,iDAAiD;QACjD,6CAA6C;QAC7C,IAAIK,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;QAU9C;;;;;KAKC,GACD,IAAIX,MAAMM,QAAQ,KAAKF,MAAMC,gBAAgB,IAAID,MAAMD,KAAK,EAAE;YAC5D,OAAO;gBACLA,OAAO;gBACPE,kBAAkBL,MAAMM,QAAQ;YAClC;QACF;QACA,OAAO;YACLH,OAAOC,MAAMD,KAAK;YAClBE,kBAAkBL,MAAMM,QAAQ;QAClC;IACF;IAMA,yIAAyI;IACzIM,SAA0B;QACxB,uFAAuF;QACvF,iHAAiH;QACjH,IAAI,IAAI,CAACR,KAAK,CAACD,KAAK,IAAI,CAACV,gBAAgB;YACvC,OAAA,WAAA,OACE,yOAAA,EAAA,6OAAA,EAAA;;sCACE,wOAAA,EAACF,qQAAAA,EAAAA;wBAAeY,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;;oBACtC,IAAI,CAACH,KAAK,CAACa,WAAW;oBACtB,IAAI,CAACb,KAAK,CAACc,YAAY;sCACxB,wOAAA,EAACC,IAAI,CAACf,KAAK,CAACgB,cAAc,EAAA;wBACxBb,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;wBACvBF,OAAO,IAAI,CAACA,KAAK;;;;QAIzB;QAEA,OAAO,IAAI,CAACD,KAAK,CAACiB,QAAQ;IAC5B;AACF;AAWO,SAASC,cAAc,EAC5BF,cAAc,EACdH,WAAW,EACXC,YAAY,EACZG,QAAQ,EAGT;IACC,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,oEAAoE;IACpE,MAAMX,eAAWlB,4QAAAA;IACjB,IAAI4B,gBAAgB;QAClB,OAAA,WAAA,OACE,wOAAA,EAACnB,sBAAAA;YACCS,UAAUA;YACVU,gBAAgBA;YAChBH,aAAaA;YACbC,cAAcA;sBAEbG;;IAGP;IAEA,OAAA,WAAA,OAAO,wOAAA,EAAA,6OAAA,EAAA;kBAAGA;;AACZ","ignoreList":[0]}},
    {"offset": {"line": 8785, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/errors/root-error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n"],"names":["React","GracefulDegradeBoundary","ErrorBoundary","isBot","isBotUserAgent","window","navigator","userAgent","RootErrorBoundary","children","errorComponent","errorStyles","errorScripts"],"mappings":";;;;;AAEA,OAAOA,WAAyB,QAAO;AACvC,OAAOC,6BAA6B,8BAA6B;AACjE,SAASC,aAAa,QAAiC,oBAAmB;AAC1E,SAASC,KAAK,QAAQ,0CAAyC;AAL/D;;;;;;AAOA,MAAMC,iBACJ,OAAOC,2CAAW,mBAAeF,2QAAAA,EAAME,OAAOC,SAAS,CAACC,SAAS;AAEpD,SAASC,kBAAkB,EACxCC,QAAQ,EACRC,cAAc,EACdC,WAAW,EACXC,YAAY,EACuC;IACnD,IAAIR,gBAAgB;;IAMpB,OAAA,WAAA,OACE,wOAAA,EAACF,+PAAAA,EAAAA;QACCQ,gBAAgBA;QAChBC,aAAaA;QACbC,cAAcA;kBAEbH;;AAGP","ignoreList":[0]}},
    {"offset": {"line": 8815, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/builtin/global-error.tsx"],"sourcesContent":["'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n"],"names":["HandleISRError","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","DefaultGlobalError","digest","html","id","head","body","div","style","h2","window","location","hostname","p"],"mappings":";;;;;AAEA,SAASA,cAAc,QAAQ,sBAAqB;AAFpD;;;AAIA,MAAMC,SAAS;IACbC,OAAO;QACL,0FAA0F;QAC1FC,YACE;QACFC,QAAQ;QACRC,WAAW;QACXC,SAAS;QACTC,eAAe;QACfC,YAAY;QACZC,gBAAgB;IAClB;IACAC,MAAM;QACJC,UAAU;QACVC,YAAY;QACZC,YAAY;QACZC,QAAQ;IACV;AACF;AAKA,SAASC,mBAAmB,EAAEb,KAAK,EAAkB;IACnD,MAAMc,SAA6Bd,OAAOc;IAC1C,OAAA,WAAA,GACE,6OAAA,EAACC,QAAAA;QAAKC,IAAG;;8BACP,wOAAA,EAACC,QAAAA,CAAAA;8BACD,yOAAA,EAACC,QAAAA;;sCACC,wOAAA,EAACpB,qQAAAA,EAAAA;wBAAeE,OAAOA;;sCACvB,wOAAA,EAACmB,OAAAA;wBAAIC,OAAOrB,OAAOC,KAAK;kCACtB,WAAA,OAAA,yOAAA,EAACmB,OAAAA;;kDACC,yOAAA,EAACE,MAAAA;oCAAGD,OAAOrB,OAAOS,IAAI;;wCAAE;wCACAM,SAAS,WAAW;wCAAS;wCACvBQ,OAAOC,QAAQ,CAACC,QAAQ;wCAAC;wCAAU;wCAC9DV,SAAS,gBAAgB;wCAAkB;;;gCAG7CA,SAAAA,WAAAA,OAAS,wOAAA,EAACW,KAAAA;oCAAEL,OAAOrB,OAAOS,IAAI;8CAAG,CAAC,QAAQ,EAAEM,QAAQ;qCAAQ;;;;;;;;AAMzE;uCAIeD,mBAAkB","ignoreList":[0]}},
    {"offset": {"line": 8888, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/navigation-devtools.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { Params } from '../../server/request/params'\nimport {\n  createDevToolsInstrumentedPromise,\n  type InstrumentedPromise,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\n/**\n * Promises are cached by tree to ensure stability across suspense retries.\n */\ntype LayoutSegmentPromisesCache = {\n  selectedLayoutSegmentPromises: Map<string, InstrumentedPromise<string | null>>\n  selectedLayoutSegmentsPromises: Map<string, InstrumentedPromise<string[]>>\n}\n\nconst layoutSegmentPromisesCache = new WeakMap<\n  FlightRouterState,\n  LayoutSegmentPromisesCache\n>()\n\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */\nexport function createLayoutSegmentPromises(\n  tree: FlightRouterState\n): LayoutSegmentPromisesCache | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Check if we already have cached promises for this tree\n  const cached = layoutSegmentPromisesCache.get(tree)\n  if (cached) {\n    return cached\n  }\n\n  // Create new promises and cache them\n  const segmentPromises = new Map<string, InstrumentedPromise<string | null>>()\n  const segmentsPromises = new Map<string, InstrumentedPromise<string[]>>()\n\n  const parallelRoutes = tree[1]\n  for (const parallelRouteKey of Object.keys(parallelRoutes)) {\n    const segments = getSelectedLayoutSegmentPath(tree, parallelRouteKey)\n\n    // Use the shared logic to compute the segment value\n    const segment = computeSelectedLayoutSegment(segments, parallelRouteKey)\n\n    segmentPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegment', segment)\n    )\n    segmentsPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegments', segments)\n    )\n  }\n\n  const result: LayoutSegmentPromisesCache = {\n    selectedLayoutSegmentPromises: segmentPromises,\n    selectedLayoutSegmentsPromises: segmentsPromises,\n  }\n\n  // Cache the result for future renders\n  layoutSegmentPromisesCache.set(tree, result)\n\n  return result\n}\n\nconst rootNavigationPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<string, NavigationPromises>\n>()\n\n/**\n * Creates instrumented navigation promises for the root app-router.\n */\nexport function createRootNavigationPromises(\n  tree: FlightRouterState,\n  pathname: string,\n  searchParams: URLSearchParams,\n  pathParams: Params\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Create stable cache keys from the values\n  const searchParamsString = searchParams.toString()\n  const pathParamsString = JSON.stringify(pathParams)\n  const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`\n\n  // Get or create the cache for this tree\n  let treeCache = rootNavigationPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<string, NavigationPromises>()\n    rootNavigationPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this combination\n  const cached = treeCache.get(cacheKey)\n  if (cached) {\n    return cached\n  }\n\n  const readonlySearchParams = new ReadonlyURLSearchParams(searchParams)\n\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n\n  const promises: NavigationPromises = {\n    pathname: createDevToolsInstrumentedPromise('usePathname', pathname),\n    searchParams: createDevToolsInstrumentedPromise(\n      'useSearchParams',\n      readonlySearchParams\n    ),\n    params: createDevToolsInstrumentedPromise('useParams', pathParams),\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(cacheKey, promises)\n\n  return promises\n}\n\nconst nestedLayoutPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<NavigationPromises | null, NavigationPromises>\n>()\n\n/**\n * Creates merged navigation promises for nested layouts.\n * Merges parent promises with layout-specific segment promises.\n */\nexport function createNestedLayoutNavigationPromises(\n  tree: FlightRouterState,\n  parentNavPromises: NavigationPromises | null\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  const parallelRoutes = tree[1]\n  const parallelRouteKeys = Object.keys(parallelRoutes)\n\n  // Only create promises if there are parallel routes at this level\n  if (parallelRouteKeys.length === 0) {\n    return null\n  }\n\n  // Get or create the cache for this tree\n  let treeCache = nestedLayoutPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<NavigationPromises | null, NavigationPromises>()\n    nestedLayoutPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this parent combination\n  const cached = treeCache.get(parentNavPromises)\n  if (cached) {\n    return cached\n  }\n\n  // Create merged promises\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n  const promises: NavigationPromises = {\n    ...parentNavPromises!,\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(parentNavPromises, promises)\n\n  return promises\n}\n"],"names":["createDevToolsInstrumentedPromise","computeSelectedLayoutSegment","getSelectedLayoutSegmentPath","ReadonlyURLSearchParams","layoutSegmentPromisesCache","WeakMap","createLayoutSegmentPromises","tree","process","env","NODE_ENV","cached","get","segmentPromises","Map","segmentsPromises","parallelRoutes","parallelRouteKey","Object","keys","segments","segment","set","result","selectedLayoutSegmentPromises","selectedLayoutSegmentsPromises","rootNavigationPromisesCache","createRootNavigationPromises","pathname","searchParams","pathParams","searchParamsString","toString","pathParamsString","JSON","stringify","cacheKey","treeCache","readonlySearchParams","layoutSegmentPromises","promises","params","nestedLayoutPromisesCache","createNestedLayoutNavigationPromises","parentNavPromises","parallelRouteKeys","length"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8994, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/hot-reloader/shared.ts"],"sourcesContent":["import type { HmrMessageSentToBrowser } from '../../../server/dev/hot-reloader-types'\n\nexport const REACT_REFRESH_FULL_RELOAD =\n  '[Fast Refresh] performing full reload\\n\\n' +\n  \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n  'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n  'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n  'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n  'Fast Refresh requires at least one parent function component in your React tree.'\n\nexport const REACT_REFRESH_FULL_RELOAD_FROM_ERROR =\n  '[Fast Refresh] performing full reload because your application had an unrecoverable error'\n\nexport function reportInvalidHmrMessage(\n  message: HmrMessageSentToBrowser | MessageEvent<unknown>,\n  err: unknown\n) {\n  console.warn(\n    '[HMR] Invalid message: ' +\n      JSON.stringify(message) +\n      '\\n' +\n      ((err instanceof Error && err?.stack) || '')\n  )\n}\n"],"names":["REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","reportInvalidHmrMessage","message","err","console","warn","JSON","stringify","Error","stack"],"mappings":";;;;;;;;AAEO,MAAMA,4BACX,8CACA,mIACA,qIACA,+GACA,8HACA,mFAAkF;AAE7E,MAAMC,uCACX,4FAA2F;AAEtF,SAASC,wBACdC,OAAwD,EACxDC,GAAY;IAEZC,QAAQC,IAAI,CACV,4BACEC,KAAKC,SAAS,CAACL,WACf,OACC,CAACC,eAAeK,SAASL,KAAKM,SAAU,EAAC;AAEhD","ignoreList":[0]}},
    {"offset": {"line": 9011, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/lib/console.ts"],"sourcesContent":["import isError from '../../lib/is-error'\n\nfunction formatObject(arg: unknown, depth: number) {\n  switch (typeof arg) {\n    case 'object':\n      if (arg === null) {\n        return 'null'\n      } else if (Array.isArray(arg)) {\n        let result = '['\n        if (depth < 1) {\n          for (let i = 0; i < arg.length; i++) {\n            if (result !== '[') {\n              result += ','\n            }\n            if (Object.prototype.hasOwnProperty.call(arg, i)) {\n              result += formatObject(arg[i], depth + 1)\n            }\n          }\n        } else {\n          result += arg.length > 0 ? '...' : ''\n        }\n        result += ']'\n        return result\n      } else if (arg instanceof Error) {\n        return arg + ''\n      } else {\n        const keys = Object.keys(arg)\n        let result = '{'\n        if (depth < 1) {\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            const desc = Object.getOwnPropertyDescriptor(arg, 'key')\n            if (desc && !desc.get && !desc.set) {\n              const jsonKey = JSON.stringify(key)\n              if (jsonKey !== '\"' + key + '\"') {\n                result += jsonKey + ': '\n              } else {\n                result += key + ': '\n              }\n              result += formatObject(desc.value, depth + 1)\n            }\n          }\n        } else {\n          result += keys.length > 0 ? '...' : ''\n        }\n        result += '}'\n        return result\n      }\n    case 'string':\n      return JSON.stringify(arg)\n    case 'number':\n    case 'bigint':\n    case 'boolean':\n    case 'symbol':\n    case 'undefined':\n    case 'function':\n    default:\n      return String(arg)\n  }\n}\n\nexport function formatConsoleArgs(args: unknown[]): string {\n  let message: string\n  let idx: number\n  if (typeof args[0] === 'string') {\n    message = args[0]\n    idx = 1\n  } else {\n    message = ''\n    idx = 0\n  }\n  let result = ''\n  let startQuote = false\n  for (let i = 0; i < message.length; ++i) {\n    const char = message[i]\n    if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n      result += char\n      continue\n    }\n\n    const code = message[++i]\n    switch (code) {\n      case 'c': {\n        // TODO: We should colorize with HTML instead of turning into a string.\n        // Ignore for now.\n        result = startQuote ? `${result}]` : `[${result}`\n        startQuote = !startQuote\n        idx++\n        break\n      }\n      case 'O':\n      case 'o': {\n        result += formatObject(args[idx++], 0)\n        break\n      }\n      case 'd':\n      case 'i': {\n        result += parseInt(args[idx++] as any, 10)\n        break\n      }\n      case 'f': {\n        result += parseFloat(args[idx++] as any)\n        break\n      }\n      case 's': {\n        result += String(args[idx++])\n        break\n      }\n      default:\n        result += '%' + code\n    }\n  }\n\n  for (; idx < args.length; idx++) {\n    result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0)\n  }\n\n  return result\n}\n\nexport function parseConsoleArgs(args: unknown[]): {\n  environmentName: string | null\n  error: Error | null\n} {\n  // See\n  // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n  //\n  // Logs replayed from the server look like this:\n  // [\n  //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n  //   \"background: #e6e6e6; ...\",\n  //   \" Server \", // can also be e.g. \" Prerender \"\n  //   \"\",\n  //   Error,\n  //   \"The above error occurred in the <Page> component.\",\n  //   ...\n  // ]\n  if (\n    args.length > 3 &&\n    typeof args[0] === 'string' &&\n    args[0].startsWith('%c%s%c') &&\n    typeof args[1] === 'string' &&\n    typeof args[2] === 'string' &&\n    typeof args[3] === 'string'\n  ) {\n    const environmentName = args[2]\n    const maybeError = args[4]\n\n    return {\n      environmentName: environmentName.trim(),\n      error: isError(maybeError) ? maybeError : null,\n    }\n  }\n\n  return {\n    environmentName: null,\n    error: null,\n  }\n}\n"],"names":["isError","formatObject","arg","depth","Array","isArray","result","i","length","Object","prototype","hasOwnProperty","call","Error","keys","key","desc","getOwnPropertyDescriptor","get","set","jsonKey","JSON","stringify","value","String","formatConsoleArgs","args","message","idx","startQuote","char","code","parseInt","parseFloat","parseConsoleArgs","startsWith","environmentName","maybeError","trim","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9168, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/runtime-error-handler.ts"],"sourcesContent":["export const RuntimeErrorHandler = {\n  hadRuntimeError: false,\n}\n"],"names":["RuntimeErrorHandler","hadRuntimeError"],"mappings":";;;;AAAO,MAAMA,sBAAsB;IACjCC,iBAAiB;AACnB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 9179, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/hot-reloader/get-socket-url.ts"],"sourcesContent":["import { normalizedAssetPrefix } from '../../../shared/lib/normalized-asset-prefix'\n\nfunction getSocketProtocol(assetPrefix: string): string {\n  let protocol = window.location.protocol\n\n  try {\n    // assetPrefix is a url\n    protocol = new URL(assetPrefix).protocol\n  } catch {}\n\n  return protocol === 'http:' ? 'ws:' : 'wss:'\n}\n\nexport function getSocketUrl(assetPrefix: string | undefined): string {\n  const prefix = normalizedAssetPrefix(assetPrefix)\n  const protocol = getSocketProtocol(assetPrefix || '')\n\n  if (URL.canParse(prefix)) {\n    // since normalized asset prefix is ensured to be a URL format,\n    // we can safely replace the protocol\n    return prefix.replace(/^http/, 'ws')\n  }\n\n  const { hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? `:${port}` : ''}${prefix}`\n}\n"],"names":["normalizedAssetPrefix","getSocketProtocol","assetPrefix","protocol","window","location","URL","getSocketUrl","prefix","canParse","replace","hostname","port"],"mappings":";;;;AAAA,SAASA,qBAAqB,QAAQ,8CAA6C;;AAEnF,SAASC,kBAAkBC,WAAmB;IAC5C,IAAIC,WAAWC,OAAOC,QAAQ,CAACF,QAAQ;IAEvC,IAAI;QACF,uBAAuB;QACvBA,WAAW,IAAIG,IAAIJ,aAAaC,QAAQ;IAC1C,EAAE,OAAM,CAAC;IAET,OAAOA,aAAa,UAAU,QAAQ;AACxC;AAEO,SAASI,aAAaL,WAA+B;IAC1D,MAAMM,aAASR,4QAAAA,EAAsBE;IACrC,MAAMC,WAAWF,kBAAkBC,eAAe;IAElD,IAAII,IAAIG,QAAQ,CAACD,SAAS;QACxB,+DAA+D;QAC/D,qCAAqC;QACrC,OAAOA,OAAOE,OAAO,CAAC,SAAS;IACjC;IAEA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAE,GAAGR,OAAOC,QAAQ;IAC1C,OAAO,GAAGF,SAAS,EAAE,EAAEQ,WAAWC,OAAO,CAAC,CAAC,EAAEA,MAAM,GAAG,KAAKJ,QAAQ;AACrE","ignoreList":[0]}},
    {"offset": {"line": 9208, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/hot-reloader/app/web-socket.ts"],"sourcesContent":["import { useContext, useEffect } from 'react'\nimport { GlobalLayoutRouterContext } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { getSocketUrl } from '../get-socket-url'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n  type TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport { reportInvalidHmrMessage } from '../shared'\nimport {\n  performFullReload,\n  processMessage,\n  type StaticIndicatorState,\n} from './hot-reloader-app'\nimport { logQueue } from '../../../../next-devtools/userspace/app/forward-logs'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { WEB_SOCKET_MAX_RECONNECTIONS } from '../../../../lib/constants'\n\nlet reconnections = 0\nlet reloading = false\nlet serverSessionId: number | null = null\nlet mostRecentCompilationHash: string | null = null\n\nexport function createWebSocket(\n  assetPrefix: string,\n  staticIndicatorState: StaticIndicatorState\n) {\n  if (!self.__next_r) {\n    throw new InvariantError(\n      `Expected a request ID to be defined for the document via self.__next_r.`\n    )\n  }\n\n  let webSocket: WebSocket\n  let timer: ReturnType<typeof setTimeout>\n\n  const sendMessage = (data: string) => {\n    if (webSocket && webSocket.readyState === webSocket.OPEN) {\n      webSocket.send(data)\n    }\n  }\n\n  const processTurbopackMessage = createProcessTurbopackMessage(sendMessage)\n\n  function init() {\n    if (webSocket) {\n      webSocket.close()\n    }\n\n    const newWebSocket = new window.WebSocket(\n      `${getSocketUrl(assetPrefix)}/_next/webpack-hmr?id=${self.__next_r}`\n    )\n\n    newWebSocket.binaryType = 'arraybuffer'\n\n    function handleOnline() {\n      logQueue.onSocketReady(newWebSocket)\n\n      reconnections = 0\n      window.console.log('[HMR] connected')\n    }\n\n    function handleMessage(event: MessageEvent) {\n      // While the page is reloading, don't respond to any more messages.\n      if (reloading) {\n        return\n      }\n\n      try {\n        const message: HmrMessageSentToBrowser =\n          event.data instanceof ArrayBuffer\n            ? parseBinaryMessage(event.data)\n            : JSON.parse(event.data)\n\n        // Check for server restart in Turbopack mode\n        if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED) {\n          if (\n            serverSessionId !== null &&\n            serverSessionId !== message.data.sessionId\n          ) {\n            // Either the server's session id has changed and it's a new server, or\n            // it's been too long since we disconnected and we should reload the page.\n            window.location.reload()\n            reloading = true\n            return\n          }\n          serverSessionId = message.data.sessionId\n        }\n\n        // Track webpack compilation hash for server restart detection\n        if (\n          message.type === HMR_MESSAGE_SENT_TO_BROWSER.SYNC &&\n          'hash' in message\n        ) {\n          // If we had previously reconnected and the hash changed, the server may have restarted\n          if (\n            mostRecentCompilationHash !== null &&\n            mostRecentCompilationHash !== message.hash\n          ) {\n            window.location.reload()\n            reloading = true\n            return\n          }\n          mostRecentCompilationHash = message.hash\n        }\n\n        processMessage(\n          message,\n          sendMessage,\n          processTurbopackMessage,\n          staticIndicatorState\n        )\n      } catch (err: unknown) {\n        reportInvalidHmrMessage(event, err)\n      }\n    }\n\n    function handleDisconnect() {\n      newWebSocket.onerror = null\n      newWebSocket.onclose = null\n      newWebSocket.close()\n      reconnections++\n\n      // After 25 reconnects we'll want to reload the page as it indicates the dev server is no longer running.\n      if (reconnections > WEB_SOCKET_MAX_RECONNECTIONS) {\n        reloading = true\n        window.location.reload()\n        return\n      }\n\n      clearTimeout(timer)\n      // Try again after 5 seconds\n      timer = setTimeout(init, reconnections > 5 ? 5000 : 1000)\n    }\n\n    newWebSocket.onopen = handleOnline\n    newWebSocket.onerror = handleDisconnect\n    newWebSocket.onclose = handleDisconnect\n    newWebSocket.onmessage = handleMessage\n\n    webSocket = newWebSocket\n    return newWebSocket\n  }\n\n  return init()\n}\n\nexport function createProcessTurbopackMessage(\n  sendMessage: (data: string) => void\n): (msg: TurbopackMessageSentToBrowser) => void {\n  if (!process.env.TURBOPACK) {\n    return () => {}\n  }\n\n  let queue: TurbopackMessageSentToBrowser[] = []\n  let callback: ((msg: TurbopackMessageSentToBrowser) => void) | undefined\n\n  const processTurbopackMessage = (msg: TurbopackMessageSentToBrowser) => {\n    if (callback) {\n      callback(msg)\n    } else {\n      queue.push(msg)\n    }\n  }\n\n  import(\n    // @ts-expect-error requires \"moduleResolution\": \"node16\" in tsconfig.json and not .ts extension\n    '@vercel/turbopack-ecmascript-runtime/browser/dev/hmr-client/hmr-client.ts'\n  ).then(({ connect }) => {\n    connect({\n      addMessageListener(cb: (msg: TurbopackMessageSentToBrowser) => void) {\n        callback = cb\n\n        // Replay all Turbopack messages before we were able to establish the HMR client.\n        for (const msg of queue) {\n          cb(msg)\n        }\n        queue.length = 0\n      },\n      sendMessage,\n      onUpdateError: (err: unknown) => performFullReload(err, sendMessage),\n    })\n  })\n\n  return processTurbopackMessage\n}\n\nexport function useWebSocketPing(webSocket: WebSocket | undefined) {\n  const { tree } = useContext(GlobalLayoutRouterContext)\n\n  useEffect(() => {\n    if (!webSocket) {\n      throw new InvariantError('Expected webSocket to be defined in dev mode.')\n    }\n\n    // Never send pings when using Turbopack as it's not used.\n    // Pings were originally used to keep track of active routes in on-demand-entries with webpack.\n    if (process.env.TURBOPACK) {\n      return\n    }\n\n    // Taken from on-demand-entries-client.js\n    const interval = setInterval(() => {\n      if (webSocket.readyState === webSocket.OPEN) {\n        webSocket.send(\n          JSON.stringify({\n            event: 'ping',\n            tree,\n            appDirRoute: true,\n          })\n        )\n      }\n    }, 2500)\n    return () => clearInterval(interval)\n  }, [tree, webSocket])\n}\n\nconst textDecoder = new TextDecoder()\n\nfunction parseBinaryMessage(data: ArrayBuffer): HmrMessageSentToBrowser {\n  assertByteLength(data, 1)\n  const view = new DataView(data)\n  const messageType = view.getUint8(0)\n\n  switch (messageType) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      assertByteLength(data, 2)\n      const requestIdLength = view.getUint8(1)\n      assertByteLength(data, 2 + requestIdLength)\n\n      const requestId = textDecoder.decode(\n        new Uint8Array(data, 2, requestIdLength)\n      )\n\n      const chunk =\n        data.byteLength > 2 + requestIdLength\n          ? new Uint8Array(data, 2 + requestIdLength)\n          : null\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK,\n        requestId,\n        chunk,\n      }\n    }\n    default: {\n      throw new InvariantError(\n        `Invalid binary HMR message of type ${messageType}`\n      )\n    }\n  }\n}\n\nfunction assertByteLength(data: ArrayBuffer, expectedLength: number) {\n  if (data.byteLength < expectedLength) {\n    throw new InvariantError(\n      `Invalid binary HMR message: insufficient data (expected ${expectedLength} bytes, got ${data.byteLength})`\n    )\n  }\n}\n"],"names":["useContext","useEffect","GlobalLayoutRouterContext","getSocketUrl","HMR_MESSAGE_SENT_TO_BROWSER","reportInvalidHmrMessage","performFullReload","processMessage","logQueue","InvariantError","WEB_SOCKET_MAX_RECONNECTIONS","reconnections","reloading","serverSessionId","mostRecentCompilationHash","createWebSocket","assetPrefix","staticIndicatorState","self","__next_r","webSocket","timer","sendMessage","data","readyState","OPEN","send","processTurbopackMessage","createProcessTurbopackMessage","init","close","newWebSocket","window","WebSocket","binaryType","handleOnline","onSocketReady","console","log","handleMessage","event","message","ArrayBuffer","parseBinaryMessage","JSON","parse","type","TURBOPACK_CONNECTED","sessionId","location","reload","SYNC","hash","err","handleDisconnect","onerror","onclose","clearTimeout","setTimeout","onopen","onmessage","process","env","TURBOPACK","queue","callback","msg","push","then","connect","addMessageListener","cb","length","onUpdateError","useWebSocketPing","tree","interval","setInterval","stringify","appDirRoute","clearInterval","textDecoder","TextDecoder","assertByteLength","view","DataView","messageType","getUint8","REACT_DEBUG_CHUNK","requestIdLength","requestId","decode","Uint8Array","chunk","byteLength","expectedLength"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9416, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/report-hmr-latency.ts"],"sourcesContent":["declare global {\n  interface Window {\n    __NEXT_HMR_LATENCY_CB: ((latencyMs: number) => void) | undefined\n  }\n}\n\n/**\n * Logs information about a completed HMR to the console, the server (via a\n * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging\n * hook).\n *\n * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a\n *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by\n *   turbopack when we must report a message to the browser console (because we\n *   already logged a \"rebuilding\" message), but it's not a real HMR, so we\n *   don't want to impact our telemetry.\n */\nexport default function reportHmrLatency(\n  sendMessage: (message: string) => void,\n  updatedModules: ReadonlyArray<string | number>,\n  startMsSinceEpoch: number,\n  endMsSinceEpoch: number,\n  hasUpdate: boolean = true\n) {\n  const latencyMs = endMsSinceEpoch - startMsSinceEpoch\n  console.log(`[Fast Refresh] done in ${latencyMs}ms`)\n  if (!hasUpdate) {\n    return\n  }\n  sendMessage(\n    JSON.stringify({\n      event: 'client-hmr-latency',\n      id: window.__nextDevClientId,\n      startTime: startMsSinceEpoch,\n      endTime: endMsSinceEpoch,\n      page: window.location.pathname,\n      updatedModules,\n      // Whether the page (tab) was hidden at the time the event occurred.\n      // This can impact the accuracy of the event's timing.\n      isPageHidden: document.visibilityState === 'hidden',\n    })\n  )\n  if (self.__NEXT_HMR_LATENCY_CB) {\n    self.__NEXT_HMR_LATENCY_CB(latencyMs)\n  }\n}\n"],"names":["reportHmrLatency","sendMessage","updatedModules","startMsSinceEpoch","endMsSinceEpoch","hasUpdate","latencyMs","console","log","JSON","stringify","event","id","window","__nextDevClientId","startTime","endTime","page","location","pathname","isPageHidden","document","visibilityState","self","__NEXT_HMR_LATENCY_CB"],"mappings":"AAMA;;;;;;;;;;CAUC,GACD;;;;AAAe,SAASA,iBACtBC,WAAsC,EACtCC,cAA8C,EAC9CC,iBAAyB,EACzBC,eAAuB,EACvBC,YAAqB,IAAI;IAEzB,MAAMC,YAAYF,kBAAkBD;IACpCI,QAAQC,GAAG,CAAC,CAAC,uBAAuB,EAAEF,UAAU,EAAE,CAAC;IACnD,IAAI,CAACD,WAAW;QACd;IACF;IACAJ,YACEQ,KAAKC,SAAS,CAAC;QACbC,OAAO;QACPC,IAAIC,OAAOC,iBAAiB;QAC5BC,WAAWZ;QACXa,SAASZ;QACTa,MAAMJ,OAAOK,QAAQ,CAACC,QAAQ;QAC9BjB;QACA,oEAAoE;QACpE,sDAAsD;QACtDkB,cAAcC,SAASC,eAAe,KAAK;IAC7C;IAEF,IAAIC,KAAKC,qBAAqB,EAAE;QAC9BD,KAAKC,qBAAqB,CAAClB;IAC7B;AACF","ignoreList":[0]}},
    {"offset": {"line": 9455, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/hot-reloader/turbopack-hot-reloader-common.ts"],"sourcesContent":["import type { TurbopackMessage } from '../../../server/dev/hot-reloader-types'\nimport type { Update as TurbopackUpdate } from '../../../build/swc/types'\n\ndeclare global {\n  interface Window {\n    __NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS: boolean | undefined\n  }\n}\n\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100\n\ninterface HmrUpdate {\n  hasUpdates: boolean\n  updatedModules: Set<string>\n  startMsSinceEpoch: number\n  endMsSinceEpoch: number\n}\n\nexport class TurbopackHmr {\n  #updatedModules: Set<string>\n  #startMsSinceEpoch: number | undefined\n  #lastUpdateMsSinceEpoch: number | undefined\n  #deferredReportHmrStartId: ReturnType<typeof setTimeout> | undefined\n  #reportedHmrStart: boolean\n\n  constructor() {\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n  }\n\n  // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n  // as it reports *any* compilation, including fully no-op/cached compilations\n  // and those unrelated to HMR. Fixing this would require significant\n  // architectural changes.\n  //\n  // Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n  // a BUILT event within that threshold and nothing has changed, just suppress\n  // the message entirely.\n  #runDeferredReportHmrStart() {\n    if (this.#deferredReportHmrStartId != null) {\n      console.log('[Fast Refresh] rebuilding')\n      this.#reportedHmrStart = true\n      this.#cancelDeferredReportHmrStart()\n    }\n  }\n\n  #cancelDeferredReportHmrStart() {\n    clearTimeout(this.#deferredReportHmrStartId)\n    this.#deferredReportHmrStartId = undefined\n  }\n\n  onBuilding() {\n    this.#lastUpdateMsSinceEpoch = undefined\n    this.#cancelDeferredReportHmrStart()\n    this.#startMsSinceEpoch = Date.now()\n\n    // report the HMR start after a short delay\n    this.#deferredReportHmrStartId = setTimeout(\n      () => this.#runDeferredReportHmrStart(),\n      // debugging feature: don't defer/suppress noisy no-op HMR update messages\n      self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS\n        ? 0\n        : TURBOPACK_HMR_START_DELAY_MS\n    )\n  }\n\n  /** Helper for other `onEvent` methods. */\n  #onUpdate() {\n    this.#runDeferredReportHmrStart()\n    this.#lastUpdateMsSinceEpoch = Date.now()\n  }\n\n  onTurbopackMessage(msg: TurbopackMessage) {\n    this.#onUpdate()\n    const updatedModules = extractModulesFromTurbopackMessage(msg.data)\n    for (const module of updatedModules) {\n      this.#updatedModules.add(module)\n    }\n  }\n\n  onServerComponentChanges() {\n    this.#onUpdate()\n  }\n\n  onReloadPage() {\n    this.#onUpdate()\n  }\n\n  onPageAddRemove() {\n    this.#onUpdate()\n  }\n\n  /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */\n  onBuilt(): HmrUpdate | null {\n    // Check that we got *any* `TurbopackMessage`, even if\n    // `updatedModules` is empty (not everything gets recorded there).\n    //\n    // There's also a case where `onBuilt` gets called before `onBuilding`,\n    // which can happen during initial page load. Ignore that too!\n    const hasUpdates =\n      this.#lastUpdateMsSinceEpoch != null && this.#startMsSinceEpoch != null\n    if (!hasUpdates && !this.#reportedHmrStart) {\n      // suppress the update entirely\n      this.#cancelDeferredReportHmrStart()\n      return null\n    }\n    this.#runDeferredReportHmrStart()\n\n    const result = {\n      hasUpdates,\n      updatedModules: this.#updatedModules,\n      startMsSinceEpoch: this.#startMsSinceEpoch!,\n      endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now(),\n    }\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n    return result\n  }\n}\n\nfunction extractModulesFromTurbopackMessage(\n  data: TurbopackUpdate | TurbopackUpdate[]\n): Set<string> {\n  const updatedModules: Set<string> = new Set()\n\n  const updates = Array.isArray(data) ? data : [data]\n  for (const update of updates) {\n    // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n    if (\n      update.type !== 'partial' ||\n      update.instruction.type !== 'ChunkListUpdate' ||\n      update.instruction.merged === undefined\n    ) {\n      continue\n    }\n\n    for (const mergedUpdate of update.instruction.merged) {\n      for (const name of Object.keys(mergedUpdate.entries)) {\n        const res = /(.*)\\s+[([].*/.exec(name)\n        if (res === null) {\n          continue\n        }\n\n        updatedModules.add(res[1])\n      }\n    }\n  }\n\n  return updatedModules\n}\n"],"names":["TURBOPACK_HMR_START_DELAY_MS","TurbopackHmr","constructor","Set","console","log","clearTimeout","undefined","onBuilding","Date","now","setTimeout","self","__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS","onTurbopackMessage","msg","updatedModules","extractModulesFromTurbopackMessage","data","module","add","onServerComponentChanges","onReloadPage","onPageAddRemove","onBuilt","hasUpdates","result","startMsSinceEpoch","endMsSinceEpoch","updates","Array","isArray","update","type","instruction","merged","mergedUpdate","name","Object","keys","entries","res","exec"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9572, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/debug-channel.ts"],"sourcesContent":["import { NEXT_REQUEST_ID_HEADER } from '../components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport interface DebugChannelReadableWriterPair {\n  readonly readable: ReadableStream<Uint8Array>\n  readonly writer: WritableStreamDefaultWriter<Uint8Array>\n}\n\nconst pairs = new Map<string, DebugChannelReadableWriterPair>()\n\nexport function getOrCreateDebugChannelReadableWriterPair(\n  requestId: string\n): DebugChannelReadableWriterPair {\n  let pair = pairs.get(requestId)\n\n  if (!pair) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>()\n    pair = { readable, writer: writable.getWriter() }\n    pairs.set(requestId, pair)\n    pair.writer.closed.finally(() => pairs.delete(requestId))\n  }\n\n  return pair\n}\n\nexport function createDebugChannel(\n  requestHeaders: Record<string, string> | undefined\n): {\n  writable?: WritableStream\n  readable?: ReadableStream\n} {\n  let requestId: string | undefined\n\n  if (requestHeaders) {\n    requestId = requestHeaders[NEXT_REQUEST_ID_HEADER] ?? undefined\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a ${JSON.stringify(NEXT_REQUEST_ID_HEADER)} request header.`\n      )\n    }\n  } else {\n    requestId = self.__next_r\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a request ID to be defined for the document via self.__next_r.`\n      )\n    }\n  }\n\n  const { readable } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n  return { readable }\n}\n"],"names":["NEXT_REQUEST_ID_HEADER","InvariantError","pairs","Map","getOrCreateDebugChannelReadableWriterPair","requestId","pair","get","readable","writable","TransformStream","writer","getWriter","set","closed","finally","delete","createDebugChannel","requestHeaders","undefined","JSON","stringify","self","__next_r"],"mappings":";;;;;;AAAA,SAASA,sBAAsB,QAAQ,mCAAkC;AACzE,SAASC,cAAc,QAAQ,mCAAkC;;;AAOjE,MAAMC,QAAQ,IAAIC;AAEX,SAASC,0CACdC,SAAiB;IAEjB,IAAIC,OAAOJ,MAAMK,GAAG,CAACF;IAErB,IAAI,CAACC,MAAM;QACT,MAAM,EAAEE,QAAQ,EAAEC,QAAQ,EAAE,GAAG,IAAIC;QACnCJ,OAAO;YAAEE;YAAUG,QAAQF,SAASG,SAAS;QAAG;QAChDV,MAAMW,GAAG,CAACR,WAAWC;QACrBA,KAAKK,MAAM,CAACG,MAAM,CAACC,OAAO,CAAC,IAAMb,MAAMc,MAAM,CAACX;IAChD;IAEA,OAAOC;AACT;AAEO,SAASW,mBACdC,cAAkD;IAKlD,IAAIb;IAEJ,IAAIa,gBAAgB;QAClBb,YAAYa,cAAc,CAAClB,+QAAAA,CAAuB,IAAImB;QAEtD,IAAI,CAACd,WAAW;YACd,MAAM,OAAA,cAEL,CAFK,IAAIJ,0PAAAA,CACR,CAAC,WAAW,EAAEmB,KAAKC,SAAS,CAACrB,+QAAAA,EAAwB,gBAAgB,CAAC,GADlE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF,OAAO;QACLK,YAAYiB,KAAKC,QAAQ;QAEzB,IAAI,CAAClB,WAAW;YACd,MAAM,OAAA,cAEL,CAFK,IAAIJ,0PAAAA,CACR,CAAC,uEAAuE,CAAC,GADrE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IAEA,MAAM,EAAEO,QAAQ,EAAE,GAAGJ,0CAA0CC;IAE/D,OAAO;QAAEG;IAAS;AACpB","ignoreList":[0]}},
    {"offset": {"line": 9626, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/dev/hot-reloader/app/hot-reloader-app.tsx"],"sourcesContent":["/// <reference types=\"webpack/module.d.ts\" />\n\nimport type { ReactNode } from 'react'\nimport { useEffect, startTransition } from 'react'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\nimport formatWebpackMessages from '../../../../shared/lib/format-webpack-messages'\nimport {\n  REACT_REFRESH_FULL_RELOAD,\n  REACT_REFRESH_FULL_RELOAD_FROM_ERROR,\n} from '../shared'\nimport {\n  dispatcher,\n  getSerializedOverlayState,\n  getSegmentTrieData,\n} from 'next/dist/compiled/next-devtools'\nimport { ReplaySsrOnlyErrors } from '../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors'\nimport { AppDevOverlayErrorBoundary } from '../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary'\nimport { useErrorHandler } from '../../../../next-devtools/userspace/app/errors/use-error-handler'\nimport { RuntimeErrorHandler } from '../../runtime-error-handler'\nimport { useWebSocketPing } from './web-socket'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  HMR_MESSAGE_SENT_TO_SERVER,\n} from '../../../../server/dev/hot-reloader-types'\nimport type {\n  HmrMessageSentToBrowser,\n  TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport type { McpErrorStateResponse } from '../../../../shared/lib/mcp-error-types'\nimport type { McpPageMetadataResponse } from '../../../../shared/lib/mcp-page-metadata-types'\nimport { useUntrackedPathname } from '../../../components/navigation-untracked'\nimport reportHmrLatency from '../../report-hmr-latency'\nimport { TurbopackHmr } from '../turbopack-hot-reloader-common'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../../components/app-router-headers'\nimport {\n  publicAppRouterInstance,\n  type GlobalErrorState,\n} from '../../../components/app-router-instance'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { getOrCreateDebugChannelReadableWriterPair } from '../../debug-channel'\n\nexport interface StaticIndicatorState {\n  pathname: string | null\n  appIsrManifest: Record<string, boolean> | null\n}\n\nlet mostRecentCompilationHash: any = null\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now())\nlet reloading = false\nlet webpackStartMsSinceEpoch: number | null = null\nconst turbopackHmr: TurbopackHmr | null = process.env.TURBOPACK\n  ? new TurbopackHmr()\n  : null\n\nlet pendingHotUpdateWebpack = Promise.resolve()\nlet resolvePendingHotUpdateWebpack: () => void = () => {}\nfunction setPendingHotUpdateWebpack() {\n  pendingHotUpdateWebpack = new Promise((resolve) => {\n    resolvePendingHotUpdateWebpack = () => {\n      resolve()\n    }\n  })\n}\n\nexport function waitForWebpackRuntimeHotUpdate() {\n  return pendingHotUpdateWebpack\n}\n\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash: string) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash\n}\n\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */\nfunction isUpdateAvailable() {\n  if (process.env.TURBOPACK) {\n    return true\n  }\n\n  /* globals __webpack_hash__ */\n  // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_hash__\n}\n\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n  return module.hot.status() === 'idle'\n}\nfunction afterApplyUpdates(fn: any) {\n  if (canApplyUpdates()) {\n    fn()\n  } else {\n    function handler(status: any) {\n      if (status === 'idle') {\n        module.hot.removeStatusHandler(handler)\n        fn()\n      }\n    }\n    module.hot.addStatusHandler(handler)\n  }\n}\n\nexport function performFullReload(\n  err: any,\n  sendMessage: (data: string) => void\n) {\n  const stackTrace =\n    err &&\n    ((err.stack && err.stack.split('\\n').slice(0, 5).join('\\n')) ||\n      err.message ||\n      err + '')\n\n  sendMessage(\n    JSON.stringify({\n      event: 'client-full-reload',\n      stackTrace,\n      hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,\n      dependencyChain: err ? err.dependencyChain : undefined,\n    })\n  )\n\n  if (reloading) return\n  reloading = true\n  window.location.reload()\n}\n\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage: (message: string) => void) {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    resolvePendingHotUpdateWebpack()\n    dispatcher.onBuildOk()\n    reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch!, Date.now())\n    return\n  }\n\n  function handleApplyUpdates(\n    err: any,\n    updatedModules: (string | number)[] | null\n  ) {\n    if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n      if (err) {\n        console.warn(REACT_REFRESH_FULL_RELOAD)\n      } else if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n      }\n      performFullReload(err, sendMessage)\n      return\n    }\n\n    dispatcher.onBuildOk()\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdatesWebpack(sendMessage)\n      return\n    }\n\n    dispatcher.onRefresh()\n    resolvePendingHotUpdateWebpack()\n    reportHmrLatency(\n      sendMessage,\n      updatedModules,\n      webpackStartMsSinceEpoch!,\n      Date.now()\n    )\n\n    if (process.env.__NEXT_TEST_MODE) {\n      afterApplyUpdates(() => {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      })\n    }\n  }\n\n  // https://webpack.js.org/api/hot-module-replacement/#check\n  module.hot\n    .check(/* autoApply */ false)\n    .then((updatedModules: (string | number)[] | null) => {\n      if (updatedModules == null) {\n        return null\n      }\n\n      // We should always handle an update, even if updatedModules is empty (but\n      // non-null) for any reason. That's what webpack would normally do:\n      // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n      dispatcher.onBeforeRefresh()\n      // https://webpack.js.org/api/hot-module-replacement/#apply\n      return module.hot.apply()\n    })\n    .then(\n      (updatedModules: (string | number)[] | null) => {\n        handleApplyUpdates(null, updatedModules)\n      },\n      (err: any) => {\n        handleApplyUpdates(err, null)\n      }\n    )\n}\n\n/** Handles messages from the server for the App Router. */\nexport function processMessage(\n  message: HmrMessageSentToBrowser,\n  sendMessage: (message: string) => void,\n  processTurbopackMessage: (msg: TurbopackMessageSentToBrowser) => void,\n  staticIndicatorState: StaticIndicatorState\n) {\n  function handleErrors(errors: ReadonlyArray<unknown>) {\n    // \"Massage\" webpack messages.\n    const formatted = formatWebpackMessages({\n      errors: errors,\n      warnings: [],\n    })\n\n    // Only show the first error.\n    dispatcher.onBuildError(formatted.errors[0])\n\n    // Also log them to the console.\n    for (let i = 0; i < formatted.errors.length; i++) {\n      console.error(stripAnsi(formatted.errors[i]))\n    }\n\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (process.env.__NEXT_TEST_MODE) {\n      if (self.__NEXT_HMR_CB) {\n        self.__NEXT_HMR_CB(formatted.errors[0])\n        self.__NEXT_HMR_CB = null\n      }\n    }\n  }\n\n  function handleHotUpdate() {\n    if (process.env.TURBOPACK) {\n      const hmrUpdate = turbopackHmr!.onBuilt()\n      if (hmrUpdate != null) {\n        reportHmrLatency(\n          sendMessage,\n          [...hmrUpdate.updatedModules],\n          hmrUpdate.startMsSinceEpoch,\n          hmrUpdate.endMsSinceEpoch,\n          // suppress the `client-hmr-latency` event if the update was a no-op:\n          hmrUpdate.hasUpdates\n        )\n      }\n      dispatcher.onBuildOk()\n    } else {\n      tryApplyUpdatesWebpack(sendMessage)\n    }\n  }\n\n  switch (message.type) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST: {\n      if (process.env.__NEXT_DEV_INDICATOR) {\n        staticIndicatorState.appIsrManifest = message.data\n\n        // Handle the initial static indicator status on receiving the ISR\n        // manifest. Navigation is handled in an effect inside HotReload for\n        // pathname changes as we'll receive the updated manifest before\n        // usePathname triggers for a new value.\n\n        const isStatic = staticIndicatorState.pathname\n          ? message.data[staticIndicatorState.pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILDING: {\n      dispatcher.buildingIndicatorShow()\n\n      if (process.env.TURBOPACK) {\n        turbopackHmr!.onBuilding()\n      } else {\n        webpackStartMsSinceEpoch = Date.now()\n        setPendingHotUpdateWebpack()\n        console.log('[Fast Refresh] rebuilding')\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SYNC: {\n      dispatcher.buildingIndicatorHide()\n\n      if (message.hash) {\n        handleAvailableHash(message.hash)\n      }\n\n      const { errors, warnings } = message\n\n      // Is undefined when it's a 'built' event\n      if ('versionInfo' in message)\n        dispatcher.onVersionInfo(message.versionInfo)\n      if ('debug' in message && message.debug)\n        dispatcher.onDebugInfo(message.debug)\n      if ('devIndicator' in message)\n        dispatcher.onDevIndicator(message.devIndicator)\n      if ('devToolsConfig' in message)\n        dispatcher.onDevToolsConfig(message.devToolsConfig)\n\n      const hasErrors = Boolean(errors && errors.length)\n      // Compilation with errors (e.g. syntax error or missing modules).\n      if (hasErrors) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-error',\n            errorCount: errors.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        handleErrors(errors)\n        return\n      }\n\n      const hasWarnings = Boolean(warnings && warnings.length)\n      if (hasWarnings) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-warning',\n            warningCount: warnings.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        // Print warnings to the console.\n        const formattedMessages = formatWebpackMessages({\n          warnings: warnings,\n          errors: [],\n        })\n\n        for (let i = 0; i < formattedMessages.warnings.length; i++) {\n          if (i === 5) {\n            console.warn(\n              'There were more warnings in other files.\\n' +\n                'You can find a complete log in the terminal.'\n            )\n            break\n          }\n          console.warn(stripAnsi(formattedMessages.warnings[i]))\n        }\n\n        // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n      }\n\n      sendMessage(\n        JSON.stringify({\n          event: 'client-success',\n          clientId: __nextDevClientId,\n        })\n      )\n\n      if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n        handleHotUpdate()\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n        data: {\n          sessionId: message.data.sessionId,\n        },\n      })\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {\n      turbopackHmr!.onTurbopackMessage(message)\n      dispatcher.onBeforeRefresh()\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n        data: message.data,\n      })\n      if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n        performFullReload(null, sendMessage)\n      }\n      dispatcher.onRefresh()\n      break\n    }\n    // TODO-APP: make server component change more granular\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {\n      turbopackHmr?.onServerComponentChanges()\n      sendMessage(\n        JSON.stringify({\n          event: 'server-component-reload-page',\n          clientId: __nextDevClientId,\n          hash: message.hash,\n        })\n      )\n\n      // Store the latest hash in a session cookie so that it's sent back to the\n      // server with any subsequent requests.\n      document.cookie = `${NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`\n\n      if (\n        RuntimeErrorHandler.hadRuntimeError ||\n        document.documentElement.id === '__next_error__'\n      ) {\n        if (reloading) return\n        reloading = true\n        return window.location.reload()\n      }\n\n      startTransition(() => {\n        publicAppRouterInstance.hmrRefresh()\n        dispatcher.onRefresh()\n      })\n\n      if (process.env.__NEXT_TEST_MODE) {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE: {\n      turbopackHmr?.onReloadPage()\n      sendMessage(\n        JSON.stringify({\n          event: 'client-reload-page',\n          clientId: __nextDevClientId,\n        })\n      )\n      if (reloading) return\n      reloading = true\n      return window.location.reload()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n    case HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE: {\n      turbopackHmr?.onPageAddRemove()\n      // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n      return publicAppRouterInstance.hmrRefresh()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR: {\n      const { errorJSON } = message\n      if (errorJSON) {\n        const errorObject = JSON.parse(errorJSON)\n        const error = new Error(errorObject.message)\n        error.stack = errorObject.stack\n        handleErrors([error])\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG: {\n      dispatcher.onDevToolsConfig(message.data)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      const { requestId, chunk } = message\n      const { writer } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n      if (chunk) {\n        writer.ready.then(() => writer.write(chunk)).catch(console.error)\n      } else {\n        // A null chunk signals that no more chunks will be sent, which allows\n        // us to close the writer.\n        // TODO: Revisit this cleanup logic when we integrate the return channel\n        // that keeps the connection open to be able to lazily retrieve debug\n        // objects.\n        writer.ready.then(() => writer.close()).catch(console.error)\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE: {\n      const errorState = getSerializedOverlayState()\n      const response: McpErrorStateResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n        requestId: message.requestId,\n        errorState,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA: {\n      const segmentTrieData = getSegmentTrieData()\n      const response: McpPageMetadataResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n        requestId: message.requestId,\n        segmentTrieData,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR: {\n      dispatcher.onCacheIndicator(message.state)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n      // These action types are handled in src/client/page-bootstrap.ts\n      break\n    default: {\n      message satisfies never\n    }\n  }\n}\n\nexport default function HotReload({\n  children,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  children: ReactNode\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  useErrorHandler(dispatcher.onUnhandledError, dispatcher.onUnhandledRejection)\n  useWebSocketPing(webSocket)\n\n  // We don't want access of the pathname for the dev tools to trigger a dynamic\n  // access (as the dev overlay will never be present in production).\n  const pathname = useUntrackedPathname()\n\n  if (process.env.__NEXT_DEV_INDICATOR) {\n    // this conditional is only for dead-code elimination which\n    // isn't a runtime conditional only build-time so ignore hooks rule\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!staticIndicatorState) {\n        throw new InvariantError(\n          'Expected staticIndicatorState to be defined in dev mode.'\n        )\n      }\n\n      staticIndicatorState.pathname = pathname\n\n      if (staticIndicatorState.appIsrManifest) {\n        const isStatic = pathname\n          ? staticIndicatorState.appIsrManifest[pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n    }, [pathname, staticIndicatorState])\n  }\n\n  return (\n    <AppDevOverlayErrorBoundary globalError={globalError}>\n      <ReplaySsrOnlyErrors onBlockingError={dispatcher.openErrorOverlay} />\n      {children}\n    </AppDevOverlayErrorBoundary>\n  )\n}\n"],"names":["useEffect","startTransition","stripAnsi","formatWebpackMessages","REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","dispatcher","getSerializedOverlayState","getSegmentTrieData","ReplaySsrOnlyErrors","AppDevOverlayErrorBoundary","useErrorHandler","RuntimeErrorHandler","useWebSocketPing","HMR_MESSAGE_SENT_TO_BROWSER","HMR_MESSAGE_SENT_TO_SERVER","useUntrackedPathname","reportHmrLatency","TurbopackHmr","NEXT_HMR_REFRESH_HASH_COOKIE","publicAppRouterInstance","InvariantError","getOrCreateDebugChannelReadableWriterPair","mostRecentCompilationHash","__nextDevClientId","Math","round","random","Date","now","reloading","webpackStartMsSinceEpoch","turbopackHmr","process","env","TURBOPACK","pendingHotUpdateWebpack","Promise","resolve","resolvePendingHotUpdateWebpack","setPendingHotUpdateWebpack","waitForWebpackRuntimeHotUpdate","handleAvailableHash","hash","isUpdateAvailable","__webpack_hash__","canApplyUpdates","module","hot","status","afterApplyUpdates","fn","handler","removeStatusHandler","addStatusHandler","performFullReload","err","sendMessage","stackTrace","stack","split","slice","join","message","JSON","stringify","event","hadRuntimeError","dependencyChain","undefined","window","location","reload","tryApplyUpdatesWebpack","onBuildOk","handleApplyUpdates","updatedModules","console","warn","onRefresh","__NEXT_TEST_MODE","self","__NEXT_HMR_CB","check","then","onBeforeRefresh","apply","processMessage","processTurbopackMessage","staticIndicatorState","handleErrors","errors","formatted","warnings","onBuildError","i","length","error","handleHotUpdate","hmrUpdate","onBuilt","startMsSinceEpoch","endMsSinceEpoch","hasUpdates","type","ISR_MANIFEST","__NEXT_DEV_INDICATOR","appIsrManifest","data","isStatic","pathname","onStaticIndicator","BUILDING","buildingIndicatorShow","onBuilding","log","BUILT","SYNC","buildingIndicatorHide","onVersionInfo","versionInfo","debug","onDebugInfo","onDevIndicator","devIndicator","onDevToolsConfig","devToolsConfig","hasErrors","Boolean","errorCount","clientId","hasWarnings","warningCount","formattedMessages","TURBOPACK_CONNECTED","sessionId","TURBOPACK_MESSAGE","onTurbopackMessage","SERVER_COMPONENT_CHANGES","onServerComponentChanges","document","cookie","documentElement","id","hmrRefresh","RELOAD_PAGE","onReloadPage","ADDED_PAGE","REMOVED_PAGE","onPageAddRemove","SERVER_ERROR","errorJSON","errorObject","parse","Error","DEV_PAGES_MANIFEST_UPDATE","DEVTOOLS_CONFIG","REACT_DEBUG_CHUNK","requestId","chunk","writer","ready","write","catch","close","REQUEST_CURRENT_ERROR_STATE","errorState","response","MCP_ERROR_STATE_RESPONSE","url","href","REQUEST_PAGE_METADATA","segmentTrieData","MCP_PAGE_METADATA_RESPONSE","CACHE_INDICATOR","onCacheIndicator","state","MIDDLEWARE_CHANGES","CLIENT_CHANGES","SERVER_ONLY_CHANGES","HotReload","children","globalError","webSocket","onUnhandledError","onUnhandledRejection","onBlockingError","openErrorOverlay"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10082, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/app-router.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nexport function createEmptyCacheNode(): CacheNode {\n  return {\n    lazyData: null,\n    rsc: null,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    parallelRoutes: new Map(),\n    loading: null,\n    navigatedAt: -1,\n  }\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n"],"names":["React","useEffect","useMemo","startTransition","useInsertionEffect","useDeferredValue","AppRouterContext","LayoutRouterContext","GlobalLayoutRouterContext","ACTION_RESTORE","createHrefFromUrl","SearchParamsContext","PathnameContext","PathParamsContext","NavigationPromisesContext","dispatchAppRouterAction","useActionQueue","AppRouterAnnouncer","RedirectBoundary","findHeadInCache","unresolvedThenable","removeBasePath","hasBasePath","getSelectedParams","useNavFailureHandler","dispatchTraverseAction","publicAppRouterInstance","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RedirectType","pingVisibleLinks","RootErrorBoundary","DefaultGlobalError","RootLayoutBoundary","globalMutable","HistoryUpdater","appRouterState","process","env","__NEXT_APP_NAV_FAIL_HANDLING","window","next","__pendingUrl","undefined","tree","pushRef","canonicalUrl","renderedSearch","appHistoryState","historyState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","URL","location","href","pushState","replaceState","nextUrl","createEmptyCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","parallelRoutes","Map","loading","navigatedAt","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","Router","actionQueue","globalError","webSocket","staticIndicatorState","searchParams","pathname","url","NODE_ENV","cache","nd","router","handlePageShow","event","persisted","pendingMpaPath","type","addEventListener","removeEventListener","handleUnhandledRedirect","error","reason","preventDefault","redirectType","push","replace","mpaNavigation","assign","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","_unused","_N","onPopState","reload","focusAndScrollRef","previousNextUrl","matchingHead","pathParams","instrumentedNavigationPromises","createRootNavigationPromises","require","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","DevRootHTTPAccessFallbackBoundary","HotReloader","default","errorComponent","errorStyles","RuntimeStyles","Provider","value","AppRouter","globalErrorState","runtimeStyles","Set","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","size","add","forEach","cb","Promise","resolve","forceUpdate","useState","renderedStylesSize","changed","c","delete","dplId","NEXT_DEPLOYMENT_ID","map","i","link","rel","precedence"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10584, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type {\n  CacheNode,\n  FlightDataPath,\n} from '../../../shared/lib/app-router-types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\n\nimport type { AppRouterState } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialRenderedSearch: string\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialRenderedSearch,\n  initialParallelRoutes,\n  location,\n}: InitialRouterStateParameters): AppRouterState {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n  const rsc = initialSeedData?.[0]\n  const loading = initialSeedData?.[2] ?? null\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: initialParallelRoutes,\n    loading,\n    navigatedAt,\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead\n    )\n  }\n\n  const initialState = {\n    tree: initialTree,\n    cache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    renderedSearch: initialRenderedSearch,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n\n  return initialState\n}\n"],"names":["createHrefFromUrl","fillLazyItemsTillLeafWithHead","extractPathFromFlightRouterState","addRefreshMarkerToActiveParallelSegments","getFlightDataPartsFromPath","createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","initialParallelRoutes","location","initialCanonicalUrl","join","normalizedFlightData","tree","initialTree","seedData","initialSeedData","head","initialHead","rsc","loading","cache","lazyData","prefetchRsc","prefetchHead","parallelRoutes","canonicalUrl","size","undefined","initialState","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","renderedSearch","nextUrl","pathname","previousNextUrl","debugInfo"],"mappings":";;;;AAKA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,gCAAgC,QAAQ,yBAAwB;AAGzE,SAASC,wCAAwC,QAAQ,uCAAsC;AAC/F,SAASC,0BAA0B,QAAQ,4BAA2B;;;;;;AAW/D,SAASC,yBAAyB,EACvCC,WAAW,EACXC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,qBAAqB,EACrBC,QAAQ,EACqB;IAC7B,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBJ,yBAAyBK,IAAI,CAAC;IAE1D,MAAMC,2BAAuBV,sQAAAA,EAA2BG,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJQ,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGN;IACJ,gGAAgG;IAChG,gDAAgD;IAChD,MAAMO,MAAMH,iBAAiB,CAAC,EAAE;IAChC,MAAMI,UAAUJ,iBAAiB,CAAC,EAAE,IAAI;IAExC,MAAMK,QAAmB;QACvBC,UAAU;QACVH;QACAI,aAAa;QACbN,MAAM;QACNO,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBjB;QAChBY;QACAhB;IACF;IAEA,MAAMsB,eACJ,AACA,6EAD6E,qEACqE;IAClJjB,eAEIX,oSAAAA,EAAkBW,YAClBC;QAENT,yUAAAA,EAAyCa,aAAaY;IAEtD,yEAAyE;IACzE,IAAIlB,0BAA0B,QAAQA,sBAAsBmB,IAAI,KAAK,GAAG;YACtE5B,wUAAAA,EACEK,aACAiB,OACAO,WACAd,aACAE,iBACAE;IAEJ;IAEA,MAAMW,eAAe;QACnBhB,MAAMC;QACNO;QACAS,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAZ;QACAa,gBAAgBhC;QAChBiC,SAEE,AADA,AACCxC,KAAAA,iEADqE,+OACrEA,EAAiCc,gBAAgBL,UAAUgC,QAAO,KACnE;QACFC,iBAAiB;QACjBC,WAAW;IACb;IAEA,OAAOd;AACT","ignoreList":[0]}},
    {"offset": {"line": 10655, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["React","useContext","useUntrackedPathname","HTTPAccessErrorStatus","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isHTTPAccessFallbackError","warnOnce","MissingSlotContext","HTTPAccessFallbackErrorBoundary","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","process","env","NODE_ENV","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","getDerivedStateFromError","error","httpStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","HTTPAccessFallbackBoundary","hasErrorFallback"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10784, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/dev-root-http-access-fallback-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React from 'react'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\n\n// TODO: error on using forbidden and unauthorized in root layout\nexport function bailOnRootNotFound() {\n  throw new Error('notFound() is not allowed to use in root layout')\n}\n\nfunction NotAllowedRootHTTPFallbackError() {\n  bailOnRootNotFound()\n  return null\n}\n\nexport function DevRootHTTPAccessFallbackBoundary({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <HTTPAccessFallbackBoundary notFound={<NotAllowedRootHTTPFallbackError />}>\n      {children}\n    </HTTPAccessFallbackBoundary>\n  )\n}\n"],"names":["React","HTTPAccessFallbackBoundary","bailOnRootNotFound","Error","NotAllowedRootHTTPFallbackError","DevRootHTTPAccessFallbackBoundary","children","notFound"],"mappings":";;;;;;;AAEA,OAAOA,WAAW,QAAO;AACzB,SAASC,0BAA0B,QAAQ,wCAAuC;AAHlF;;;;AAMO,SAASC;IACd,MAAM,OAAA,cAA4D,CAA5D,IAAIC,MAAM,oDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA2D;AACnE;AAEA,SAASC;IACPF;IACA,OAAO;AACT;AAEO,SAASG,kCAAkC,EAChDC,QAAQ,EAGT;IACC,OAAA,WAAA,OACE,wOAAA,EAACL,0SAAAA,EAAAA;QAA2BM,UAAAA,WAAAA,OAAU,wOAAA,EAACH,iCAAAA,CAAAA;kBACpCE;;AAGP","ignoreList":[0]}},
    {"offset": {"line": 10818, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;;AAAO,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA;MAIX","ignoreList":[0]}},
    {"offset": {"line": 10831, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/layout-router.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/layout-router.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10837, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/layout-router.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/layout-router.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10844, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/layout-router.tsx"],"sourcesContent":["'use client'\n\nimport type {\n  CacheNode,\n  LazyCacheNode,\n} from '../../shared/lib/app-router-types'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../shared/lib/app-router-types'\nimport type { ErrorComponent } from './error-boundary'\nimport {\n  ACTION_SERVER_PATCH,\n  type FocusAndScrollRef,\n} from './router-reducer/router-reducer-types'\n\nimport React, {\n  Activity,\n  useContext,\n  use,\n  startTransition,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n  type ActivityProps,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { fetchServerResponse } from './router-reducer/fetch-server-response'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport {\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { getParamValueFromCacheKey } from '../route-params'\nimport type { Params } from '../../server/request/params'\n\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\nfunction walkAddRefetch(\n  segmentPathToWalk: FlightSegmentPath | undefined,\n  treeToRecreate: FlightRouterState\n): FlightRouterState {\n  if (segmentPathToWalk) {\n    const [segment, parallelRouteKey] = segmentPathToWalk\n    const isLast = segmentPathToWalk.length === 2\n\n    if (matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          const subTree = walkAddRefetch(\n            undefined,\n            treeToRecreate[1][parallelRouteKey]\n          )\n          return [\n            treeToRecreate[0],\n            {\n              ...treeToRecreate[1],\n              [parallelRouteKey]: [\n                subTree[0],\n                subTree[1],\n                subTree[2],\n                'refetch',\n              ],\n            },\n          ]\n        }\n\n        return [\n          treeToRecreate[0],\n          {\n            ...treeToRecreate[1],\n            [parallelRouteKey]: walkAddRefetch(\n              segmentPathToWalk.slice(2),\n              treeToRecreate[1][parallelRouteKey]\n            ),\n          },\n        ]\n      }\n    }\n  }\n\n  return treeToRecreate\n}\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      disableSmoothScrollDuringRouteTransition(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  debugNameContext,\n  cacheNode,\n  params,\n  url,\n  isActive,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  debugNameContext: string\n  cacheNode: CacheNode\n  params: Params\n  url: string\n  isActive: boolean\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  const parentNavPromises = useContext(NavigationPromisesContext)\n\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const { tree: fullTree } = context\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  const resolvedRsc: React.ReactNode =\n    typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'\n      ? use(rsc)\n      : rsc\n\n  if (!resolvedRsc) {\n    // The data for this segment is not available, and there's no pending\n    // navigation that will be able to fulfill it. We need to fetch more from\n    // the server and patch the cache.\n\n    // Only fetch data for the active segment. Inactive segments (rendered\n    // offscreen for bfcache) should not trigger fetches.\n    if (isActive) {\n      // Check if there's already a pending request.\n      let lazyData = cacheNode.lazyData\n      if (lazyData === null) {\n        /**\n         * Router state with refetch marker added\n         */\n        // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n        const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n        const navigatedAt = Date.now()\n        cacheNode.lazyData = lazyData = fetchServerResponse(\n          new URL(url, location.origin),\n          {\n            flightRouterState: refetchTree,\n            nextUrl: includeNextUrl\n              ? // We always send the last next-url, not the current when\n                // performing a dynamic request. This is because we update\n                // the next-url after a navigation, but we want the same\n                // interception route to be matched that used the last\n                // next-url.\n                context.previousNextUrl || context.nextUrl\n              : null,\n          }\n        ).then((serverResponse) => {\n          startTransition(() => {\n            dispatchAppRouterAction({\n              type: ACTION_SERVER_PATCH,\n              previousTree: fullTree,\n              serverResponse,\n              navigatedAt,\n            })\n          })\n\n          return serverResponse\n        })\n\n        // Suspend while waiting for lazyData to resolve\n        use(lazyData)\n      }\n    }\n    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n    use(unresolvedThenable) as never\n  }\n\n  // If we get to this point, then we know we have something we can render.\n  let content = resolvedRsc\n\n  // In dev, we create a NavigationPromisesContext containing the instrumented promises that provide\n  // `useSelectedLayoutSegment` and `useSelectedLayoutSegments`.\n  // Promises are cached outside of render to survive suspense retries.\n  let navigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createNestedLayoutNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    navigationPromises = createNestedLayoutNavigationPromises(\n      tree,\n      parentNavPromises\n    )\n  }\n\n  if (navigationPromises) {\n    content = (\n      <NavigationPromisesContext.Provider value={navigationPromises}>\n        {resolvedRsc}\n      </NavigationPromisesContext.Provider>\n    )\n  }\n\n  const subtree = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n        parentParams: params,\n        debugNameContext: debugNameContext,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n        isActive: isActive,\n      }}\n    >\n      {content}\n    </LayoutRouterContext.Provider>\n  )\n  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n  return subtree\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  name,\n  loading,\n  children,\n}: {\n  name: ActivityProps['name']\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server  which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        name={name}\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  segmentViewBoundaries,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  segmentViewBoundaries?: React.ReactNode\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const {\n    parentTree,\n    parentCacheNode,\n    parentSegmentPath,\n    parentParams,\n    url,\n    isActive,\n    debugNameContext,\n  } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React  it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  const activeSegment = activeTree[0]\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment  we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n    const cacheKey = createRouterCacheKey(segment)\n\n    // Read segment path from the parallel router cache node.\n    let cacheNode = segmentMap.get(cacheKey)\n    if (cacheNode === undefined) {\n      // When data is not available during rendering client-side we need to fetch\n      // it from the server.\n      const newLazyCacheNode: LazyCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n\n      // Flight data fetch kicked off during render and put into the cache.\n      cacheNode = newLazyCacheNode\n      segmentMap.set(cacheKey, newLazyCacheNode)\n    }\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    let segmentBoundaryTriggerNode: React.ReactNode = null\n    let segmentViewStateNode: React.ReactNode = null\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      const pagePrefix = normalizeAppPath(url)\n      segmentViewStateNode = (\n        <SegmentViewStateNode key={pagePrefix} page={pagePrefix} />\n      )\n\n      segmentBoundaryTriggerNode = (\n        <>\n          <SegmentBoundaryTriggerNode />\n        </>\n      )\n    }\n\n    let params = parentParams\n    if (Array.isArray(segment)) {\n      // This segment contains a route param. Accumulate these as we traverse\n      // down the router tree. The result represents the set of params that\n      // the layout/page components are permitted to access below this point.\n      const paramName = segment[0]\n      const paramCacheKey = segment[1]\n      const paramType = segment[2]\n      const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType)\n      if (paramValue !== null) {\n        params = {\n          ...parentParams,\n          [paramName]: paramValue,\n        }\n      }\n    }\n\n    const debugName = getBoundaryDebugNameFromSegment(segment)\n    // `debugNameContext` represents the nearest non-\"virtual\" parent segment.\n    // `getBoundaryDebugNameFromSegment` returns undefined for virtual segments.\n    // So if `debugName` is undefined, the context is passed through unchanged.\n    const childDebugNameContext = debugName ?? debugNameContext\n\n    // In practical terms, clicking this name in the Suspense DevTools\n    // should select the child slots of that layout.\n    //\n    // So the name we apply to the Activity boundary is actually based on\n    // the nearest parent segments.\n    //\n    // We skip over \"virtual\" parents, i.e. ones inserted by Next.js that\n    // don't correspond to application-defined code.\n    const isVirtual = debugName === undefined\n    const debugNameToDisplay = isVirtual ? undefined : debugNameContext\n\n    // TODO: The loading module data for a segment is stored on the parent, then\n    // applied to each of that parent segment's parallel route slots. In the\n    // simple case where there's only one parallel route (the `children` slot),\n    // this is no different from if the loading module data where stored on the\n    // child directly. But I'm not sure this actually makes sense when there are\n    // multiple parallel routes. It's not a huge issue because you always have\n    // the option to define a narrower loading boundary for a particular slot. But\n    // this sort of smells like an implementation accident to me.\n    const loadingModuleData = parentCacheNode.loading\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundary\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary\n                name={debugNameToDisplay}\n                loading={loadingModuleData}\n              >\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      params={params}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                      debugNameContext={childDebugNameContext}\n                      isActive={isActive && stateKey === activeStateKey}\n                    />\n                    {segmentBoundaryTriggerNode}\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundary>\n            {segmentViewStateNode}\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentStateProvider } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      child = (\n        <SegmentStateProvider key={stateKey}>\n          {child}\n          {segmentViewBoundaries}\n        </SegmentStateProvider>\n      )\n    }\n\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n      child = (\n        <Activity\n          name={debugNameToDisplay}\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n\nfunction getBoundaryDebugNameFromSegment(segment: Segment): string | undefined {\n  if (segment === '/') {\n    // Reached the root\n    return '/'\n  }\n  if (typeof segment === 'string') {\n    if (isVirtualLayout(segment)) {\n      return undefined\n    } else {\n      return segment + '/'\n    }\n  }\n  const paramCacheKey = segment[1]\n  return paramCacheKey + '/'\n}\n\nfunction isVirtualLayout(segment: string): boolean {\n  return (\n    // This is inserted by the loader. We should consider encoding these\n    // in a more special way instead of checking the name, to distinguish them\n    // from app-defined groups.\n    segment === '(slot)'\n  )\n}\n"],"names":["ACTION_SERVER_PATCH","React","Activity","useContext","use","startTransition","Suspense","useDeferredValue","ReactDOM","LayoutRouterContext","GlobalLayoutRouterContext","TemplateContext","fetchServerResponse","unresolvedThenable","ErrorBoundary","matchSegment","disableSmoothScrollDuringRouteTransition","RedirectBoundary","HTTPAccessFallbackBoundary","createRouterCacheKey","hasInterceptionRouteInCurrentTree","dispatchAppRouterAction","useRouterBFCache","normalizeAppPath","NavigationPromisesContext","getParamValueFromCacheKey","walkAddRefetch","segmentPathToWalk","treeToRecreate","segment","parallelRouteKey","isLast","length","hasOwnProperty","subTree","undefined","slice","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","findDOMNode","instance","window","internal_reactDOMfindDOMNode","rectProperties","shouldSkipElement","element","includes","getComputedStyle","position","rect","getBoundingClientRect","every","item","topOfElementInViewport","viewportHeight","top","getHashFragmentDomNode","hashFragment","document","body","getElementById","getElementsByName","InnerScrollAndFocusHandler","Component","componentDidMount","handlePotentialScroll","componentDidUpdate","props","focusAndScrollRef","apply","render","children","segmentPath","segmentPaths","some","scrollRefSegmentPath","index","domNode","Element","HTMLElement","process","env","NODE_ENV","parentElement","localName","nextElementSibling","scrollIntoView","htmlElement","documentElement","clientHeight","scrollTop","dontForceLayout","onlyHashChange","focus","ScrollAndFocusHandler","context","Error","InnerLayoutRouter","tree","debugNameContext","cacheNode","params","url","isActive","parentNavPromises","fullTree","resolvedPrefetchRsc","prefetchRsc","rsc","resolvedRsc","then","lazyData","refetchTree","includeNextUrl","navigatedAt","Date","now","URL","location","origin","flightRouterState","nextUrl","previousNextUrl","serverResponse","type","previousTree","content","navigationPromises","createNestedLayoutNavigationPromises","require","Provider","value","subtree","parentTree","parentCacheNode","parentSegmentPath","parentParams","LoadingBoundary","name","loading","loadingModuleData","promiseForLoading","loadingRsc","loadingStyles","loadingScripts","fallback","OuterLayoutRouter","parallelRouterKey","error","errorStyles","errorScripts","templateStyles","templateScripts","template","notFound","forbidden","unauthorized","segmentViewBoundaries","parentParallelRoutes","parallelRoutes","segmentMap","get","Map","set","parentTreeSegment","concat","activeTree","activeSegment","activeStateKey","bfcacheEntry","stateKey","cacheKey","newLazyCacheNode","head","prefetchHead","segmentBoundaryTriggerNode","segmentViewStateNode","SegmentBoundaryTriggerNode","SegmentViewStateNode","pagePrefix","page","Array","isArray","paramName","paramCacheKey","paramType","paramValue","debugName","getBoundaryDebugNameFromSegment","childDebugNameContext","isVirtual","debugNameToDisplay","child","errorComponent","SegmentStateProvider","__NEXT_CACHE_COMPONENTS","mode","push","next","isVirtualLayout"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 10851, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/render-from-template-context.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/render-from-template-context.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10857, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/render-from-template-context.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/render-from-template-context.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10864, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/render-from-template-context.tsx"],"sourcesContent":["'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n"],"names":["React","useContext","TemplateContext","RenderFromTemplateContext","children"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 10871, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-page.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-page.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10877, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-page.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-page.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10884, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/client-page.tsx"],"sourcesContent":["'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\nimport { LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { use } from 'react'\nimport { urlSearchParamsToParsedUrlQuery } from '../route-params'\nimport { SearchParamsContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  serverProvidedParams,\n}: {\n  Component: React.ComponentType<any>\n  serverProvidedParams: null | {\n    searchParams: ParsedUrlQuery\n    params: Params\n    promises: Array<Promise<any>> | null\n  }\n}) {\n  let searchParams: ParsedUrlQuery\n  let params: Params\n  if (serverProvidedParams !== null) {\n    searchParams = serverProvidedParams.searchParams\n    params = serverProvidedParams.params\n  } else {\n    // When Cache Components is enabled, the server does not pass the params as\n    // props; they are parsed on the client and passed via context.\n    const layoutRouterContext = use(LayoutRouterContext)\n    params =\n      layoutRouterContext !== null ? layoutRouterContext.parentParams : {}\n\n    // This is an intentional behavior change: when Cache Components is enabled,\n    // client segments receive the \"canonical\" search params, not the\n    // rewritten ones. Users should either call useSearchParams directly or pass\n    // the rewritten ones in from a Server Component.\n    // TODO: Log a deprecation error when this object is accessed\n    searchParams = urlSearchParamsToParsedUrlQuery(use(SearchParamsContext)!)\n  }\n\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n"],"names":["InvariantError","LayoutRouterContext","use","urlSearchParamsToParsedUrlQuery","SearchParamsContext","ClientPageRoot","Component","serverProvidedParams","searchParams","params","layoutRouterContext","parentParams","window","workAsyncStorage","require","clientSearchParams","clientParams","store","getStore","createSearchParamsFromClient","createParamsFromClient","createRenderSearchParamsFromClient","createRenderParamsFromClient"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 10891, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-segment.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-segment.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10897, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-segment.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/client-segment.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10904, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/client-segment.tsx"],"sourcesContent":["'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\nimport { LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { use } from 'react'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  serverProvidedParams,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  serverProvidedParams: null | {\n    params: Params\n    promises: Array<Promise<any>> | null\n  }\n}) {\n  let params: Params\n  if (serverProvidedParams !== null) {\n    params = serverProvidedParams.params\n  } else {\n    // When Cache Components is enabled, the server does not pass the params\n    // as props; they are parsed on the client and passed via context.\n    const layoutRouterContext = use(LayoutRouterContext)\n    params =\n      layoutRouterContext !== null ? layoutRouterContext.parentParams : {}\n  }\n\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n"],"names":["InvariantError","LayoutRouterContext","use","ClientSegmentRoot","Component","slots","serverProvidedParams","params","layoutRouterContext","parentParams","window","workAsyncStorage","require","clientParams","store","getStore","createParamsFromClient","createRenderParamsFromClient"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 10912, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DYNAMIC_ERROR_CODE","DynamicServerError","Error","constructor","description","digest","isDynamicServerError","err"],"mappings":";;;;;;AAAA,MAAMA,qBAAqB;AAEpB,MAAMC,2BAA2BC;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAC,CAAC,sBAAsB,EAAEA,aAAa,GAAA,IAAA,CADlBA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCL;IAIpC;AACF;AAEO,SAASM,qBAAqBC,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKL;AACxB","ignoreList":[0]}},
    {"offset": {"line": 10934, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["NEXT_STATIC_GEN_BAILOUT","StaticGenBailoutError","Error","code","isStaticGenBailoutError","error"],"mappings":";;;;;;AAAA,MAAMA,0BAA0B;AAEzB,MAAMC,8BAA8BC;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOH;;AACzB;AAEO,SAASI,wBACdC,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMF,IAAI,KAAKH;AACxB","ignoreList":[0]}},
    {"offset": {"line": 10955, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10961, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 10968, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["React","useContext","useUntrackedPathname","HTTPAccessErrorStatus","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isHTTPAccessFallbackError","warnOnce","MissingSlotContext","HTTPAccessFallbackErrorBoundary","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","process","env","NODE_ENV","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","getDerivedStateFromError","error","httpStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","HTTPAccessFallbackBoundary","hasErrorFallback"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 10976, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","HTTP_ERROR_FALLBACK_ERROR_CODE","isHTTPAccessFallbackError","error","digest","prefix","httpStatus","split","has","Number","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","status"],"mappings":";;;;;;;;;;;;AAAO,MAAMA,wBAAwB;IACnCC,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB,EAAC;AAED,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACP;AAErC,MAAMQ,iCAAiC,2BAA0B;AAajE,SAASC,0BACdC,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWJ,kCACXJ,cAAcW,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASI,4BACdP,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASK,mCACdC,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 11022, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN"],"mappings":";;;;;;;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;;AAEpD,MAAMC,sBAAsB,gBAAe;AAE3C,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;MAGX;AAaM,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcd,6QAAAA;AAElB","ignoreList":[0]}},
    {"offset": {"line": 11053, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isHTTPAccessFallbackError","isRedirectError","isNextRouterError","error"],"mappings":";;;;AAAA,SACEA,yBAAyB,QAEpB,8CAA6C;AACpD,SAASC,eAAe,QAA4B,mBAAkB;;;AAO/D,SAASC,kBACdC,KAAc;IAEd,WAAOF,iQAAAA,EAAgBE,cAAUH,kTAAAA,EAA0BG;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 11067, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/image-component.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/image-component.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 11073, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/image-component.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/dist/esm/client/image-component.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 11080, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/image-component.tsx"],"sourcesContent":["'use client'\n\nimport React, {\n  useRef,\n  useEffect,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n  forwardRef,\n  use,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport Head from '../shared/lib/head'\nimport { getImgProps } from '../shared/lib/get-img-props'\nimport type {\n  ImageProps,\n  ImgProps,\n  OnLoad,\n  OnLoadingComplete,\n  PlaceholderValue,\n} from '../shared/lib/get-img-props'\nimport type {\n  ImageConfigComplete,\n  ImageLoaderProps,\n} from '../shared/lib/image-config'\nimport { imageConfigDefault } from '../shared/lib/image-config'\nimport { ImageConfigContext } from '../shared/lib/image-config-context.shared-runtime'\nimport { warnOnce } from '../shared/lib/utils/warn-once'\nimport { RouterContext } from '../shared/lib/router-context.shared-runtime'\n\n// This is replaced by webpack alias\nimport defaultLoader from 'next/dist/shared/lib/image-loader'\nimport { useMergedRef } from './use-merged-ref'\n\n// This is replaced by webpack define plugin\nconst configEnv = process.env.__NEXT_IMAGE_OPTS as any as ImageConfigComplete\n\nif (typeof window === 'undefined') {\n  ;(globalThis as any).__NEXT_IMAGE_IMPORTED = true\n}\n\nexport type { ImageLoaderProps }\nexport type ImageLoader = (p: ImageLoaderProps) => string\n\ntype ImgElementWithDataProp = HTMLImageElement & {\n  'data-loaded-src': string | undefined\n}\n\ntype ImageElementProps = ImgProps & {\n  unoptimized: boolean\n  placeholder: PlaceholderValue\n  onLoadRef: React.MutableRefObject<OnLoad | undefined>\n  onLoadingCompleteRef: React.MutableRefObject<OnLoadingComplete | undefined>\n  setBlurComplete: (b: boolean) => void\n  setShowAltText: (b: boolean) => void\n  sizesInput: string | undefined\n}\n\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(\n  img: ImgElementWithDataProp,\n  placeholder: PlaceholderValue,\n  onLoadRef: React.MutableRefObject<OnLoad | undefined>,\n  onLoadingCompleteRef: React.MutableRefObject<OnLoadingComplete | undefined>,\n  setBlurComplete: (b: boolean) => void,\n  unoptimized: boolean,\n  sizesInput: string | undefined\n) {\n  const src = img?.src\n  if (!img || img['data-loaded-src'] === src) {\n    return\n  }\n  img['data-loaded-src'] = src\n  const p = 'decode' in img ? img.decode() : Promise.resolve()\n  p.catch(() => {}).then(() => {\n    if (!img.parentElement || !img.isConnected) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return\n    }\n    if (placeholder !== 'empty') {\n      setBlurComplete(true)\n    }\n    if (onLoadRef?.current) {\n      // Since we don't have the SyntheticEvent here,\n      // we must create one with the same shape.\n      // See https://reactjs.org/docs/events.html\n      const event = new Event('load')\n      Object.defineProperty(event, 'target', { writable: false, value: img })\n      let prevented = false\n      let stopped = false\n      onLoadRef.current({\n        ...event,\n        nativeEvent: event,\n        currentTarget: img,\n        target: img,\n        isDefaultPrevented: () => prevented,\n        isPropagationStopped: () => stopped,\n        persist: () => {},\n        preventDefault: () => {\n          prevented = true\n          event.preventDefault()\n        },\n        stopPropagation: () => {\n          stopped = true\n          event.stopPropagation()\n        },\n      })\n    }\n    if (onLoadingCompleteRef?.current) {\n      onLoadingCompleteRef.current(img)\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const origSrc = new URL(src, 'http://n').searchParams.get('url') || src\n      if (img.getAttribute('data-nimg') === 'fill') {\n        if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n          let widthViewportRatio =\n            img.getBoundingClientRect().width / window.innerWidth\n          if (widthViewportRatio < 0.6) {\n            if (sizesInput === '100vw') {\n              warnOnce(\n                `Image with src \"${origSrc}\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`\n              )\n            } else {\n              warnOnce(\n                `Image with src \"${origSrc}\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`\n              )\n            }\n          }\n        }\n        if (img.parentElement) {\n          const { position } = window.getComputedStyle(img.parentElement)\n          const valid = ['absolute', 'fixed', 'relative']\n          if (!valid.includes(position)) {\n            warnOnce(\n              `Image with src \"${origSrc}\" has \"fill\" and parent element with invalid \"position\". Provided \"${position}\" should be one of ${valid\n                .map(String)\n                .join(',')}.`\n            )\n          }\n        }\n        if (img.height === 0) {\n          warnOnce(\n            `Image with src \"${origSrc}\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`\n          )\n        }\n      }\n\n      const heightModified =\n        img.height.toString() !== img.getAttribute('height')\n      const widthModified = img.width.toString() !== img.getAttribute('width')\n      if (\n        (heightModified && !widthModified) ||\n        (!heightModified && widthModified)\n      ) {\n        warnOnce(\n          `Image with src \"${origSrc}\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio.`\n        )\n      }\n    }\n  })\n}\n\nfunction getDynamicProps(\n  fetchPriority?: string\n): Record<string, string | undefined> {\n  if (Boolean(use)) {\n    // In React 19.0.0 or newer, we must use camelCase\n    // prop to avoid \"Warning: Invalid DOM property\".\n    // See https://github.com/facebook/react/pull/25927\n    return { fetchPriority }\n  }\n  // In React 18.2.0 or older, we must use lowercase prop\n  // to avoid \"Warning: Invalid DOM property\".\n  return { fetchpriority: fetchPriority }\n}\n\nconst ImageElement = forwardRef<HTMLImageElement | null, ImageElementProps>(\n  (\n    {\n      src,\n      srcSet,\n      sizes,\n      height,\n      width,\n      decoding,\n      className,\n      style,\n      fetchPriority,\n      placeholder,\n      loading,\n      unoptimized,\n      fill,\n      onLoadRef,\n      onLoadingCompleteRef,\n      setBlurComplete,\n      setShowAltText,\n      sizesInput,\n      onLoad,\n      onError,\n      ...rest\n    },\n    forwardedRef\n  ) => {\n    const ownRef = useCallback(\n      (img: ImgElementWithDataProp | null) => {\n        if (!img) {\n          return\n        }\n        if (onError) {\n          // If the image has an error before react hydrates, then the error is lost.\n          // The workaround is to wait until the image is mounted which is after hydration,\n          // then we set the src again to trigger the error handler (if there was an error).\n          // eslint-disable-next-line no-self-assign\n          img.src = img.src\n        }\n        if (process.env.NODE_ENV !== 'production') {\n          if (!src) {\n            console.error(`Image is missing required \"src\" property:`, img)\n          }\n          if (img.getAttribute('alt') === null) {\n            console.error(\n              `Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.`\n            )\n          }\n        }\n        if (img.complete) {\n          handleLoading(\n            img,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            unoptimized,\n            sizesInput\n          )\n        }\n      },\n      [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput,\n      ]\n    )\n\n    const ref = useMergedRef(forwardedRef, ownRef)\n\n    return (\n      <img\n        {...rest}\n        {...getDynamicProps(fetchPriority)}\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading={loading}\n        width={width}\n        height={height}\n        decoding={decoding}\n        data-nimg={fill ? 'fill' : '1'}\n        className={className}\n        style={style}\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes={sizes}\n        srcSet={srcSet}\n        src={src}\n        ref={ref}\n        onLoad={(event) => {\n          const img = event.currentTarget as ImgElementWithDataProp\n          handleLoading(\n            img,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            unoptimized,\n            sizesInput\n          )\n        }}\n        onError={(event) => {\n          // if the real image fails to load, this will ensure \"alt\" is visible\n          setShowAltText(true)\n          if (placeholder !== 'empty') {\n            // If the real image fails to load, this will still remove the placeholder.\n            setBlurComplete(true)\n          }\n          if (onError) {\n            onError(event)\n          }\n        }}\n      />\n    )\n  }\n)\n\nfunction ImagePreload({\n  isAppRouter,\n  imgAttributes,\n}: {\n  isAppRouter: boolean\n  imgAttributes: ImgProps\n}) {\n  const opts: ReactDOM.PreloadOptions = {\n    as: 'image',\n    imageSrcSet: imgAttributes.srcSet,\n    imageSizes: imgAttributes.sizes,\n    crossOrigin: imgAttributes.crossOrigin,\n    referrerPolicy: imgAttributes.referrerPolicy,\n    ...getDynamicProps(imgAttributes.fetchPriority),\n  }\n\n  if (isAppRouter && ReactDOM.preload) {\n    ReactDOM.preload(imgAttributes.src, opts)\n    return null\n  }\n\n  return (\n    <Head>\n      <link\n        key={\n          '__nimg-' +\n          imgAttributes.src +\n          imgAttributes.srcSet +\n          imgAttributes.sizes\n        }\n        rel=\"preload\"\n        // Note how we omit the `href` attribute, as it would only be relevant\n        // for browsers that do not support `imagesrcset`, and in those cases\n        // it would cause the incorrect image to be preloaded.\n        //\n        // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n        href={imgAttributes.srcSet ? undefined : imgAttributes.src}\n        {...opts}\n      />\n    </Head>\n  )\n}\n\n/**\n * The `Image` component is used to optimize images.\n *\n * Read more: [Next.js docs: `Image`](https://nextjs.org/docs/app/api-reference/components/image)\n */\nexport const Image = forwardRef<HTMLImageElement | null, ImageProps>(\n  (props, forwardedRef) => {\n    const pagesRouter = useContext(RouterContext)\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter\n\n    const configContext = useContext(ImageConfigContext)\n    const config = useMemo(() => {\n      const c = configEnv || configContext || imageConfigDefault\n\n      const allSizes = [...c.deviceSizes, ...c.imageSizes].sort((a, b) => a - b)\n      const deviceSizes = c.deviceSizes.sort((a, b) => a - b)\n      const qualities = c.qualities?.sort((a, b) => a - b)\n      return {\n        ...c,\n        allSizes,\n        deviceSizes,\n        qualities,\n        // During the SSR, configEnv (__NEXT_IMAGE_OPTS) does not include\n        // security sensitive configs like `localPatterns`, which is needed\n        // during the server render to ensure it's validated. Therefore use\n        // configContext, which holds the config from the server for validation.\n        localPatterns:\n          typeof window === 'undefined'\n            ? configContext?.localPatterns\n            : c.localPatterns,\n      }\n    }, [configContext])\n\n    const { onLoad, onLoadingComplete } = props\n    const onLoadRef = useRef(onLoad)\n\n    useEffect(() => {\n      onLoadRef.current = onLoad\n    }, [onLoad])\n\n    const onLoadingCompleteRef = useRef(onLoadingComplete)\n\n    useEffect(() => {\n      onLoadingCompleteRef.current = onLoadingComplete\n    }, [onLoadingComplete])\n\n    const [blurComplete, setBlurComplete] = useState(false)\n    const [showAltText, setShowAltText] = useState(false)\n    const { props: imgAttributes, meta: imgMeta } = getImgProps(props, {\n      defaultLoader,\n      imgConf: config,\n      blurComplete,\n      showAltText,\n    })\n\n    return (\n      <>\n        {\n          <ImageElement\n            {...imgAttributes}\n            unoptimized={imgMeta.unoptimized}\n            placeholder={imgMeta.placeholder}\n            fill={imgMeta.fill}\n            onLoadRef={onLoadRef}\n            onLoadingCompleteRef={onLoadingCompleteRef}\n            setBlurComplete={setBlurComplete}\n            setShowAltText={setShowAltText}\n            sizesInput={props.sizes}\n            ref={forwardedRef}\n          />\n        }\n        {imgMeta.preload ? (\n          <ImagePreload\n            isAppRouter={isAppRouter}\n            imgAttributes={imgAttributes}\n          />\n        ) : null}\n      </>\n    )\n  }\n)\n"],"names":["React","useRef","useEffect","useCallback","useContext","useMemo","useState","forwardRef","use","ReactDOM","Head","getImgProps","imageConfigDefault","ImageConfigContext","warnOnce","RouterContext","defaultLoader","useMergedRef","configEnv","process","env","__NEXT_IMAGE_OPTS","window","globalThis","__NEXT_IMAGE_IMPORTED","handleLoading","img","placeholder","onLoadRef","onLoadingCompleteRef","setBlurComplete","unoptimized","sizesInput","src","p","decode","Promise","resolve","catch","then","parentElement","isConnected","current","event","Event","Object","defineProperty","writable","value","prevented","stopped","nativeEvent","currentTarget","target","isDefaultPrevented","isPropagationStopped","persist","preventDefault","stopPropagation","NODE_ENV","origSrc","URL","searchParams","get","getAttribute","widthViewportRatio","getBoundingClientRect","width","innerWidth","position","getComputedStyle","valid","includes","map","String","join","height","heightModified","toString","widthModified","getDynamicProps","fetchPriority","Boolean","fetchpriority","ImageElement","srcSet","sizes","decoding","className","style","loading","fill","setShowAltText","onLoad","onError","rest","forwardedRef","ownRef","console","error","complete","ref","data-nimg","ImagePreload","isAppRouter","imgAttributes","opts","as","imageSrcSet","imageSizes","crossOrigin","referrerPolicy","preload","link","rel","href","undefined","Image","props","pagesRouter","configContext","config","c","allSizes","deviceSizes","sort","a","b","qualities","localPatterns","onLoadingComplete","blurComplete","showAltText","meta","imgMeta","imgConf"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 11088, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/readonly-url-search-params.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n"],"names":["ReadonlyURLSearchParamsError","Error","constructor","ReadonlyURLSearchParams","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA;;;;CAIC,GAED,cAAc;;;;AACd,MAAMA,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAMO,MAAMC,gCAAgCC;IAC3C,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,SAAS;QACP,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,MAAM;QACJ,MAAM,IAAIP;IACZ;IACA,wKAAwK,GACxKQ,OAAO;QACL,MAAM,IAAIR;IACZ;AACF","ignoreList":[0]}},
    {"offset": {"line": 11119, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["RedirectStatusCode","RedirectType","isRedirectError","REDIRECT_ERROR_CODE","actionAsyncStorage","window","require","undefined","getRedirectError","url","type","statusCode","TemporaryRedirect","error","Error","digest","redirect","getStore","isAction","push","replace","permanentRedirect","PermanentRedirect","getURLFromRedirectError","split","slice","join","getRedirectTypeFromError","getRedirectStatusCodeFromError","Number","at"],"mappings":";;;;;;;;;;;;;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;AAC3D,SACEC,YAAY,EAEZC,eAAe,EACfC,mBAAmB,QACd,mBAAkB;;;AAEzB,MAAMC,qBACJ,OAAOC,WAAW,qBAEZC,QAAQ,8KACRF,kBAAkB,GACpBG;AAEC,SAASC,iBACdC,GAAW,EACXC,IAAkB,EAClBC,aAAiCX,6QAAAA,CAAmBY,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMX,qQAAAA,GAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CU,MAAME,MAAM,GAAG,GAAGZ,qQAAAA,CAAoB,CAAC,EAAEO,KAAK,CAAC,EAAED,IAAI,CAAC,EAAEE,WAAW,CAAC,CAAC;IACrE,OAAOE;AACT;AAcO,SAASG,SACd,2BAA2B,GAC3BP,GAAW,EACXC,IAAmB;IAEnBA,SAASN,oBAAoBa,YAAYC,WACrCjB,8PAAAA,CAAakB,IAAI,GACjBlB,8PAAAA,CAAamB,OAAO;IAExB,MAAMZ,iBAAiBC,KAAKC,MAAMV,6QAAAA,CAAmBY,iBAAiB;AACxE;AAaO,SAASS,kBACd,2BAA2B,GAC3BZ,GAAW,EACXC,OAAqBT,8PAAAA,CAAamB,OAAO;IAEzC,MAAMZ,iBAAiBC,KAAKC,MAAMV,6QAAAA,CAAmBsB,iBAAiB;AACxE;AAUO,SAASC,wBAAwBV,KAAc;IACpD,IAAI,KAACX,iQAAAA,EAAgBW,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAME,MAAM,CAACS,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAASC,yBAAyBd,KAAoB;IAC3D,IAAI,KAACX,iQAAAA,EAAgBW,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAME,MAAM,CAACS,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASI,+BAA+Bf,KAAoB;IACjE,IAAI,KAACX,iQAAAA,EAAgBW,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOe,OAAOhB,MAAME,MAAM,CAACS,KAAK,CAAC,KAAKM,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 11184, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["HTTP_ERROR_FALLBACK_ERROR_CODE","DIGEST","notFound","error","Error","digest"],"mappings":";;;;AAAA,SACEA,8BAA8B,QAEzB,8CAA6C;;AAEpD;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAS,GAAGD,uTAAAA,CAA+B,IAAI,CAAC;AAE/C,SAASE;IACd,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0]}},
    {"offset": {"line": 11217, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["HTTP_ERROR_FALLBACK_ERROR_CODE","DIGEST","forbidden","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;;AAAA,SACEA,8BAA8B,QAEzB,8CAA6C;;AAEpD,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAS,GAAGD,uTAAAA,CAA+B,IAAI,CAAC;AAE/C,SAASE;IACd,IAAI,CAACC,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 11256, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["HTTP_ERROR_FALLBACK_ERROR_CODE","DIGEST","unauthorized","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;;AAAA,SACEA,8BAA8B,QAEzB,8CAA6C;;AAEpD,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAS,GAAGD,uTAAAA,CAA+B,IAAI,CAAC;AAE/C,SAASE;IACd,IAAI,CAACC,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 11296, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["isHangingPromiseRejectionError","isPostpone","isBailoutToCSRError","isNextRouterError","isDynamicPostpone","isPrerenderInterruptedError","isDynamicServerError","unstable_rethrow","error","Error","cause"],"mappings":";;;;AAAA,SAASA,8BAA8B,QAAQ,uCAAsC;AACrF,SAASC,UAAU,QAAQ,4CAA2C;AACtE,SAASC,mBAAmB,QAAQ,+CAA8C;AAClF,SAASC,iBAAiB,QAAQ,yBAAwB;AAC1D,SACEC,iBAAiB,EACjBC,2BAA2B,QACtB,4CAA2C;AAClD,SAASC,oBAAoB,QAAQ,yBAAwB;;;;;;;AAEtD,SAASC,iBAAiBC,KAAc;IAC7C,QACEL,+QAAAA,EAAkBK,cAClBN,oRAAAA,EAAoBM,cACpBF,+QAAAA,EAAqBE,cACrBJ,yQAAAA,EAAkBI,cAClBP,qQAAAA,EAAWO,cACXR,8QAAAA,EAA+BQ,cAC/BH,mRAAAA,EAA4BG,QAC5B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBC,SAAS,WAAWD,OAAO;QAC9CD,iBAAiBC,MAAME,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 11324, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC,GACD;;;;AAAO,MAAMA,mBACX,OAAOC,WAAW,qBAEZC,QAAQ,wKACRF,gBAAgB,GAEhBE,QAAQ,8BACRF,gBAAgB,CAAA","ignoreList":[0]}},
    {"offset": {"line": 11339, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/OneDrive/Desktop/PROJECTS/coffee-store/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","unstable_isUnrecognizedActionError","Error","redirect","permanentRedirect","RedirectType","notFound","forbidden","unauthorized","unstable_rethrow"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,+BAA8B;AAQtE,SAASG,QAAQ,EAAEC,iBAAiB,QAAQ,aAAY;AACxD,SAASC,YAAY,QAAQ,mBAAkB;AAC/C,SAASC,QAAQ,QAAQ,cAAa;AACtC,SAASC,SAAS,QAAQ,cAAa;AACvC,SAASC,YAAY,QAAQ,iBAAgB;AAC7C,SAASC,gBAAgB,QAAQ,qBAAoB;;AAX9C,SAASR;IACd,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0]}}]
}